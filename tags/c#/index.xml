<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C# on brealinblog</title>
    <link>https://brealinhub.com/tags/c#/</link>
    <description>Recent content in C# on brealinblog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 06 Mar 2023 19:14:07 +0000</lastBuildDate><atom:link href="https://brealinhub.com/tags/c#/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>异步</title>
      <link>https://brealinhub.com/posts/%E5%BC%82%E6%AD%A5/</link>
      <pubDate>Mon, 06 Mar 2023 19:14:07 +0000</pubDate>
      
      <guid>https://brealinhub.com/posts/%E5%BC%82%E6%AD%A5/</guid>
      <description>查阅 MSDN 异步编程以了解更多
异步编程 在 C# 中，异步编程是一种编程范式，它允许程序异步执行任务，而不会阻塞主线程或其他任务的执行。在异步程序中，程序可以继续执行其他任务，而无需等待一个任务完成
优势 异步编程可以为需要执行 I/O 操作或其他耗时任务的应用程序提供显著的优势，例如访问数据库、下载文件或执行网络通信。通过使用异步编程，应用程序可以提高性能、响应性、可扩展性和资源效率，同时简化代码并提高容错性
误解 异步编程总是更快：虽然异步编程可以提高性能，但它并不能保证在所有情况下都能提供更快的执行速度，如果一个应用程序没有大量的 I/O 操作或耗时任务，使用异步编程可能不会提供任何性能优势，甚至可能引入不必要的复杂性
异步编程总是优于同步编程：虽然异步编程可以提高应用程序的可扩展性和响应性，但它可能并不总是最好的解决方案。异步编程可能会引入额外的复杂性，而且对于所有的用例可能都不是必需需要的
异步编程可以完全消除对线程的需求：虽然异步编程可以减少显式线程的需求，但它并不能完全消除它。异步编程仍然依赖于底层线程和线程池在后台执行任务
还有并不能完全消除锁和同步的需求、或认为异步容易调试等等
关键字 async 和 await
目标 支持读起来像一连串语句的代码，但会根据外部资源分配和任务完成时间以更复杂的顺序执行
内容 async 用以标记函数的关键字，例如：
public async Task TestAsync(){ } 但仅这还不是真正的异步函数
await 必须在 async 标记下的函数内使用的关键字，例如：
public async Task TestAsync() { await Task.delay(1000); Console.WriteLine(&amp;#34;TestDone&amp;#34;); } async 和 await 一起使用才构成了异步函数
如此例所示，await 关键字将暂停 TestAsync 方法的执行，并返回不完整的 Task，在此期间，线程将返回到线程池，以便自己可用于另一个请求，await 完成后将恢复继续向下执行
但是，如何知道 await 已经完成呢？这里就需要用到 Task，可先了解一下此站另一个 blog - 线程
总结 该操作不会在线程池线程运行
如果仅使用 async 关键字，那么函数内容仍会以同步方式进行
一般异步函数命名的最后结尾都是 Async</description>
      <content:encoded><![CDATA[<blockquote>
<p>查阅 MSDN <a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/async/">异步编程</a>以了解更多</p>
</blockquote>
<h1 id="异步编程">异步编程</h1>
<p>在 C# 中，异步编程是一种编程范式，它允许程序异步执行任务，而不会阻塞主线程或其他任务的执行。在异步程序中，程序可以继续执行其他任务，而无需等待一个任务完成</p>
<h2 id="优势">优势</h2>
<p>异步编程可以为需要执行 I/O 操作或其他耗时任务的应用程序提供显著的优势，例如访问数据库、下载文件或执行网络通信。通过使用异步编程，应用程序可以提高性能、响应性、可扩展性和资源效率，同时简化代码并提高容错性</p>
<h2 id="误解">误解</h2>
<ol>
<li>
<p>异步编程总是更快：虽然异步编程可以提高性能，但它并不能保证在所有情况下都能提供更快的执行速度，如果一个应用程序没有大量的 I/O 操作或耗时任务，使用异步编程可能不会提供任何性能优势，甚至可能引入不必要的复杂性</p>
</li>
<li>
<p>异步编程总是优于同步编程：虽然异步编程可以提高应用程序的可扩展性和响应性，但它可能并不总是最好的解决方案。异步编程可能会引入额外的复杂性，而且对于所有的用例可能都不是必需需要的</p>
</li>
<li>
<p>异步编程可以完全消除对线程的需求：虽然异步编程可以减少显式线程的需求，但它并不能完全消除它。异步编程仍然依赖于底层线程和线程池在后台执行任务</p>
</li>
</ol>
<p>还有并不能完全消除锁和同步的需求、或认为异步容易调试等等</p>
<h1 id="关键字">关键字</h1>
<p><code>async</code> 和 <code>await</code></p>
<h2 id="目标">目标</h2>
<p>支持读起来像一连串语句的代码，但会根据外部资源分配和任务完成时间以更复杂的顺序执行</p>
<h2 id="内容">内容</h2>
<h3 id="async">async</h3>
<p>用以标记函数的关键字，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="n">TestAsync</span><span class="p">(){</span> <span class="p">}</span>
</span></span></code></pre></div><p>但仅这还不是真正的异步函数</p>
<h3 id="await">await</h3>
<p>必须在 <code>async</code> 标记下的函数内使用的关键字，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="n">TestAsync</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">delay</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;TestDone&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>async</code> 和 <code>await</code> 一起使用才构成了异步函数</p>
<p>如此例所示，<code>await </code>关键字将暂停 <code>TestAsync</code> 方法的执行，并返回不完整的 <code>Task</code>，在此期间，线程将返回到线程池，以便自己可用于另一个请求，<code>await</code> 完成后将恢复继续向下执行</p>
<p>但是，如何知道 <code>await</code> 已经完成呢？这里就需要用到 <code>Task</code>，可先了解一下此站另一个 blog - <a href="https://brealinhub.com/2023/03/03/%E7%BA%BF%E7%A8%8B/">线程</a></p>
<h3 id="总结">总结</h3>
<ul>
<li>
<p>该操作不会在线程池线程运行</p>
</li>
<li>
<p>如果仅使用 <code>async</code> 关键字，那么函数内容仍会以同步方式进行</p>
</li>
<li>
<p>一般异步函数命名的最后结尾都是 Async</p>
</li>
<li>
<p>帮助我们从异步操作中提取结果</p>
</li>
<li>
<p>验证操作成功</p>
</li>
<li>
<p>提供在异步方法中执行其余代码的延续</p>
</li>
</ul>
<h1 id="task">Task</h1>
<p><code>Task</code> 抽象类是在 C# 5.0 (.NET Framwork 4.0) 引出的概念</p>
<p>大多数情况下，都是返回 <code>Task</code> 或者 <code>Task&lt;T&gt;</code>，极少数情况会返回 <code>void</code></p>
<p>因为 <code>Task</code> 返回类型可提供更加丰富的监视内容和可等待内容结果，而 <code>void</code> 没有这些，仅在异步事件处理程序使用 <code>void</code> 返回类型</p>
<h2 id="优势-1">优势</h2>
<ol>
<li>
<p>抽象类允许我们轻松的使用线程池和本地线程，且绝大多数 <code>Task</code> 都在属于线程池的后台线程中执行</p>
</li>
<li>
<p>异步操作的状态管理：<code>Task</code> 对象跟踪异步操作的状态，包括是否已经完成、是否已经取消、是否已经出错等等，开发人员可以通过访问 <code>Task</code> 的属性和方法来获取和操作异步操作的状态信息</p>
</li>
<li>
<p>异步操作的结果返回：<code>Task</code> 对象代表异步操作的最终结果，当异步操作完成时，它可以返回异步操作的结果或者抛出异常。异步方法的返回值通常是一个 <code>Task</code> 对象或者 <code>Task&lt;T&gt;</code> 对象，开发人员可以通过访问 <code>Task</code> 对象的 <code>Result</code> 属性或者使用 <code>await</code> 关键字来获取异步操作的结果</p>
</li>
<li>
<p>异步操作的协调和组合：<code>Task</code> 对象可以通过多种方式来协调和组合异步操作，例如使用 <code>Task.WhenAll</code> 或 <code>Task.WhenAny</code> 方法来等待多个异步操作的完成或者组合多个异步操作的结果</p>
</li>
<li>
<p>并行和异步编程的支持：<code>Task</code> 对象可以帮助开发人员实现并行和异步编程模式，使用异步方法和异步操作可以提高应用程序的性能和响应性，避免阻塞 UI 线程或者阻塞 CPU</p>
</li>
</ol>
<p><code>Task</code> 对象不是线程，也不会创建线程，它只是代表了异步操作的状态和行为。异步操作的实际执行可能在线程池线程、IO 线程、UI 线程或者其它线程中执行，具体取决于异步操作的实现方式和上下文</p>
<h2 id="比较">比较</h2>
<h3 id="例一">例一</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">mres</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ManualResetEventSlim</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="n">ThreadPool</span><span class="p">.</span><span class="n">QueueUserWorkItem</span><span class="p">&lt;</span><span class="n">ManualResetEventSlim</span><span class="p">&gt;((</span><span class="n">_msg</span><span class="p">)</span> <span class="p">=&gt;</span>   
</span></span><span class="line"><span class="cl">    <span class="p">{</span>   
</span></span><span class="line"><span class="cl">		<span class="n">i</span> <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">Exp</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">        <span class="n">mres</span><span class="p">.</span><span class="n">Set</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl">    <span class="p">},</span> <span class="n">mres</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">mres</span><span class="p">.</span><span class="n">Wait</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// output:2.71828182845</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>上面这个例子首先创建了 <code>ManualResetEventSlim</code> API 与其中的 <code>Set</code> 和 <code>Wait</code> 方法来控制线程池运行，再创建线程池执行内容</p>
<p>现在，我们可以用如下 <code>Task</code> 来简化操作</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">task</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="n">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">Math</span><span class="p">.</span><span class="n">Exp</span><span class="p">(</span><span class="m">1</span><span class="p">));</span>  
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">Result</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// output:2.71828182845</span>
</span></span></code></pre></div><p>与用前一个 <code>ThredPool</code> 类方法相比，<code>Task</code> 省去了创建变量和控制线程发生的过程，且用前个方法不能返回类型，而此方法在这个例子中，返回了 <code>Task&lt;double&gt;</code> 类型（具有 Result 属性）</p>
<h3 id="例二">例二</h3>
<p>in <code>BaseClass.cs</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">public</span> <span class="k">class</span> <span class="nc">CarBuilding</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="k">private</span> <span class="k">static</span> <span class="n">Body</span> <span class="n">BuildBody</span><span class="p">(</span><span class="kt">int</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Body</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="k">private</span> <span class="k">static</span> <span class="n">Engine</span> <span class="n">BuildEngine</span><span class="p">(</span><span class="kt">int</span> <span class="n">horsePower</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Engine</span><span class="p">(</span><span class="n">horsePower</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="k">private</span> <span class="k">static</span> <span class="n">Suspension</span> <span class="n">BuildSuspension</span><span class="p">(</span><span class="kt">int</span> <span class="n">supportedKg</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Suspension</span><span class="p">(</span><span class="n">supportedKg</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="k">private</span> <span class="k">static</span> <span class="n">Painting</span> <span class="n">Paint</span><span class="p">(</span><span class="kt">string</span> <span class="n">color</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bodyArea</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Painting</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">bodyArea</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Test</span><span class="p">(</span><span class="n">Body</span> <span class="n">body</span><span class="p">,</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Suspension</span><span class="p">&gt;</span> <span class="n">suspensions</span><span class="p">,</span> <span class="n">Engine</span> <span class="n">engine</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">	<span class="p">{</span>  
</span></span><span class="line"><span class="cl">	    <span class="k">if</span> <span class="p">(</span><span class="n">suspensions</span><span class="p">.</span><span class="n">Sum</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">SupportedKg</span><span class="p">)</span> <span class="p">&lt;=</span> <span class="n">body</span><span class="p">.</span><span class="n">Weight</span> <span class="p">||</span> <span class="n">engine</span><span class="p">.</span><span class="n">Horsepower</span> <span class="p">*</span> <span class="m">4</span> <span class="p">&lt;=</span> <span class="n">body</span><span class="p">.</span><span class="n">Weight</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">	        <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentException</span><span class="p">(</span><span class="s">&#34;The car weighs too much&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl">    <span class="p">{</span>        
</span></span><span class="line"><span class="cl">	    
</span></span><span class="line"><span class="cl">    <span class="p">}</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span> <span class="k">class</span> <span class="nc">Body</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="n">Body</span><span class="p">(</span><span class="kt">int</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="p">{</span>        
</span></span><span class="line"><span class="cl">	    <span class="n">Weight</span> <span class="p">=</span> <span class="n">weight</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">        <span class="n">Length</span> <span class="p">=</span> <span class="n">length</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">        <span class="n">Width</span> <span class="p">=</span> <span class="n">weight</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&#34;{Weight} and {Length} and {Width}&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}</span>   
</span></span><span class="line"><span class="cl">     
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="kt">int</span> <span class="n">Weight</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>  
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="kt">int</span> <span class="n">Length</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>  
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="kt">int</span> <span class="n">Width</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span>  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="k">public</span> <span class="k">class</span> <span class="nc">Engine</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="n">Engine</span><span class="p">(</span><span class="kt">int</span> <span class="n">horsePower</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="p">{</span>        
</span></span><span class="line"><span class="cl">	    <span class="n">Horsepower</span> <span class="p">=</span> <span class="n">horsePower</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}</span>   
</span></span><span class="line"><span class="cl">     
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="kt">int</span> <span class="n">Horsepower</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span>  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="k">public</span> <span class="k">class</span> <span class="nc">Suspension</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="n">Suspension</span><span class="p">(</span><span class="kt">int</span> <span class="n">supportedKg</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="p">{</span>        
</span></span><span class="line"><span class="cl">	    <span class="n">SupportedKg</span> <span class="p">=</span> <span class="n">supportedKg</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">	    
</span></span><span class="line"><span class="cl">		<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">SupportedKg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">       
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="kt">int</span> <span class="n">SupportedKg</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span>  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="k">public</span> <span class="k">class</span> <span class="nc">Painting</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="n">Painting</span><span class="p">(</span><span class="kt">string</span> <span class="n">color</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bodyArea</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="p">{</span>        
</span></span><span class="line"><span class="cl">	    <span class="n">Color</span> <span class="p">=</span> <span class="n">color</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">        <span class="n">BodyArea</span> <span class="p">=</span> <span class="n">bodyArea</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&#34;{Color} and {BodyArea}&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}</span>  
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="kt">string</span> <span class="n">Color</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>  
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="kt">int</span> <span class="n">BodyArea</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在  <code>Main</code> 函数中添加以下内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="n">Body</span> <span class="n">body</span> <span class="p">=</span> <span class="k">null</span><span class="p">!;</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">bodyThread</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span>  
</span></span><span class="line"><span class="cl">    <span class="p">{</span>  
</span></span><span class="line"><span class="cl">        <span class="n">body</span> <span class="p">=</span> <span class="n">BuildBody</span><span class="p">(</span><span class="m">100</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">2</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="p">});</span>    
</span></span><span class="line"><span class="cl">    <span class="n">bodyThread</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>  <span class="c1">// Thread 方法</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">bodyTask</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="n">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">BuildBody</span><span class="p">(</span><span class="m">50</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">));</span>  <span class="c1">// Task 方法</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// output: </span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 100 and 5 and 100</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 50 and 1 and 50</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这里两个方法有着区别，<code>Task</code> 在这更具优势，上文也有提到（简洁、具有返回值）</p>
<p>继续往 <code>Main</code> 函数添加内容</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="n">Body</span> <span class="n">body</span> <span class="p">=</span> <span class="k">null</span><span class="p">!;</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">bodyThread</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span>  
</span></span><span class="line"><span class="cl">    <span class="p">{</span>  
</span></span><span class="line"><span class="cl">        <span class="n">body</span> <span class="p">=</span> <span class="n">BuildBody</span><span class="p">(</span><span class="m">100</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">2</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="p">});</span>    
</span></span><span class="line"><span class="cl">    <span class="n">bodyThread</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">bodyThread</span><span class="p">.</span><span class="n">Join</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl">    <span class="n">Painting</span> <span class="n">painting</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">paintingThread</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span>  
</span></span><span class="line"><span class="cl">    <span class="p">{</span>  
</span></span><span class="line"><span class="cl">        <span class="n">painting</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Painting</span><span class="p">(</span><span class="s">&#34;red&#34;</span><span class="p">,</span> <span class="n">body</span><span class="p">.</span><span class="n">Width</span> <span class="p">*</span> <span class="n">body</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="p">});}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">	<span class="n">paintingThread</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">paintingThread</span><span class="p">.</span><span class="n">Join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// output:</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 100 and 5 and 100</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// red and 500</span>
</span></span></code></pre></div><p>上面内容用的 <code>Thread</code> 写法写出两个子线程运行的方法，下面写一个 <code>Task</code> 写法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">bodyTask</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="n">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">BuildBody</span><span class="p">(</span><span class="m">50</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">2</span><span class="p">));</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">paintingTask</span> <span class="p">=</span> <span class="n">bodyTask</span><span class="p">.</span><span class="n">ContinueWith</span><span class="p">(</span>  
</span></span><span class="line"><span class="cl">        <span class="n">task</span> <span class="p">=&gt;</span> <span class="n">Paint</span><span class="p">(</span><span class="s">&#34;red&#34;</span><span class="p">,</span> <span class="n">task</span><span class="p">.</span><span class="n">Result</span><span class="p">.</span><span class="n">Width</span> <span class="p">*</span> <span class="n">task</span><span class="p">.</span><span class="n">Result</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// output:</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 50 and 5 and 50</span>
</span></span><span class="line"><span class="cl"><span class="c1">// red and 250</span>
</span></span></code></pre></div><p>比较一下，用 <code>Task </code>方法显而易见的简洁了，其中采用了<strong>链式编程</strong>，使用了 <code>ContinueWith</code> 方法，意思是执行 <code>bodyTask</code> 线程池，并开始函数内部委托的执行，使任务之间的依赖性清晰且定义明确</p>
<p>而且 <code>ContinueWith</code> 方法也提供第二个参数，如写法：<code>task =&gt; Paint(&quot;red&quot;, task.Result.Width * task.Result.Length),TaskContinuationOptions.OnlyOnRanToCompletion</code>，第二个参数就表明前一个线程池必须完成后才执行此委托</p>
<p>在 Main 函数中添加以下内容：</p>
<p><code>Thread</code> 多个线程创建并执行写法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">System.Collections.Concurrent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">------------------------------------------------</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">suspensions</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ConcurrentBag</span><span class="p">&lt;</span><span class="n">Suspension</span><span class="p">&gt;();</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">suspensionThreads</span> <span class="p">=</span> <span class="n">Enumerable</span>  
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">i</span> <span class="p">=&gt;</span>  
</span></span><span class="line"><span class="cl">        <span class="p">{</span>  
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span>  
</span></span><span class="line"><span class="cl">            <span class="p">{</span>  
</span></span><span class="line"><span class="cl">                <span class="n">suspensions</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">BuildSuspension</span><span class="p">(</span><span class="m">40</span><span class="p">));</span>  
</span></span><span class="line"><span class="cl">            <span class="p">});</span>            
</span></span><span class="line"><span class="cl">            <span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">t</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">        <span class="p">});</span>  
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">suspThread</span> <span class="k">in</span> <span class="n">suspensionThreads</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">        <span class="n">suspThread</span><span class="p">.</span><span class="n">Join</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// output：40 40 40 ... 40 40 (10 个 40)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>ConcurrentBag</code>：表示线程安全、无序的对象集合</p>
<p>这个 API 就是为了解决多个线程池的性能问题</p>
<p>而用 <code>Task</code> 创建则无需此步骤，如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">suspensionTasks</span> <span class="p">=</span> <span class="n">Enumerable</span>  
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">i</span> <span class="p">=&gt;</span> <span class="n">Task</span><span class="p">.</span><span class="n">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">BuildSuspension</span><span class="p">(</span><span class="m">40</span><span class="p">)));</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">suspensionsTask</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="n">WhenAll</span><span class="p">(</span><span class="n">suspensionTasks</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">ContinueWith</span><span class="p">(</span><span class="n">task</span> <span class="p">=&gt;</span> <span class="n">task</span><span class="p">.</span><span class="n">Result</span><span class="p">.</span><span class="n">ToList</span><span class="p">());</span>  
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="c1">// output：40 40 40 ... 40 40 (10 个 40)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>同样省略了很多步骤，在里面使用了 <code>WhenAll</code> 方法，表明执行完所有内容并返回一个 <code>Task&lt;T&gt;</code> 类型</p>
<p>也可进一步优化为：<code>Task.Factory.ContinueWhenAll(suspensionTasks, tasks =&gt; tasks.ToList());</code></p>
<p>在 <code>Main</code> 函数添加以下内容：</p>
<p>用 <code>Thread</code> 表示线程抛出异常</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="n">Exception</span><span class="p">?</span> <span class="n">thrownException</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">body</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Body</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Suspension</span><span class="p">&gt;</span> <span class="n">suspensions</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Suspension</span><span class="p">[</span><span class="m">1</span><span class="p">];</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">engine</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Engine</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">testing</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span>  
</span></span><span class="line"><span class="cl">    <span class="p">{</span>  
</span></span><span class="line"><span class="cl">        <span class="k">try</span>  
</span></span><span class="line"><span class="cl">        <span class="p">{</span>  
</span></span><span class="line"><span class="cl">            <span class="n">Test</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">suspensions</span><span class="p">,</span> <span class="n">engine</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">        <span class="p">}</span>        
</span></span><span class="line"><span class="cl">        <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">exc</span><span class="p">)</span>   
</span></span><span class="line"><span class="cl">        <span class="p">{</span>   
</span></span><span class="line"><span class="cl">            <span class="n">thrownException</span> <span class="p">=</span> <span class="n">exc</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">        <span class="p">}</span>    
</span></span><span class="line"><span class="cl">        <span class="p">});</span>    
</span></span><span class="line"><span class="cl">        <span class="n">testing</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="n">testing</span><span class="p">.</span><span class="n">Join</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">thrownException</span> <span class="k">is</span> <span class="n">not</span> <span class="k">null</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="n">thrownException</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>只有当线程抛出异常，才会使 <code>thrownException</code> 有值，没有异常则是 <code>null</code></p>
<p><code>Tasks</code> 方法同样有内置工具检测异常，如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">body</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Body</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">);</span>    
</span></span><span class="line"><span class="cl">	<span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Suspension</span><span class="p">&gt;</span> <span class="n">suspensions</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Suspension</span><span class="p">[</span><span class="m">1</span><span class="p">];</span>    
</span></span><span class="line"><span class="cl">	<span class="kt">var</span> <span class="n">engine</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Engine</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">	<span class="k">try</span>   
</span></span><span class="line"><span class="cl">	<span class="p">{</span>  
</span></span><span class="line"><span class="cl">        <span class="kt">var</span> <span class="n">testingTask</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="n">Run</span><span class="p">(</span>  
</span></span><span class="line"><span class="cl">            <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">Test</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">suspensions</span><span class="p">,</span><span class="n">engine</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">        <span class="p">);</span>    
</span></span><span class="line"><span class="cl">    <span class="p">}</span>    
</span></span><span class="line"><span class="cl">    <span class="k">catch</span> <span class="p">(</span><span class="n">AggregateException</span> <span class="n">exc</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="p">{</span>        
</span></span><span class="line"><span class="cl">	    <span class="k">throw</span> <span class="n">exc</span><span class="p">.</span><span class="n">InnerExceptions</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在这种情况下，我们只重新抛出第一个内部异常，但我们也可以使用<code>AgggregateException.Handle()</code> 方法处理它</p>
<h2 id="tap">TAP</h2>
<p><a href="https://www.microsoft.com/download/en/details.aspx?id=19957">Task-based Asynchronous Pattern</a> 基于 <code>Task</code>的异步编程模型</p>
<p>了解任务代表异步方法的执行而不是结果非常重要，<code>Task</code> 有几个属性，指示操作是否成功完成（状态、已完成、取消、错误）</p>
<h1 id="死锁">死锁</h1>
<p>一般出现在 UI 或 ASP.NET 程序中</p>
<h2 id="内容-1">内容</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">object</span> <span class="n">lock1</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">object</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">object</span> <span class="n">lock2</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">object</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="n">Thread</span> <span class="n">t1</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">(</span><span class="n">DoWork1</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="n">Thread</span> <span class="n">t2</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">(</span><span class="n">DoWork2</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="n">t1</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl">    <span class="n">t2</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl">    <span class="n">t1</span><span class="p">.</span><span class="n">Join</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl">    <span class="n">t2</span><span class="p">.</span><span class="n">Join</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;Done.&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span>  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="k">void</span> <span class="n">DoWork1</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="k">lock</span> <span class="p">(</span><span class="n">lock1</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="p">{</span>        
</span></span><span class="line"><span class="cl">	    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;Thread 1 acquired lock1.&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">        <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">        <span class="k">lock</span> <span class="p">(</span><span class="n">lock2</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">        <span class="p">{</span>            
</span></span><span class="line"><span class="cl">	        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;Thread 1 acquired lock2.&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">        <span class="p">}</span>    
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="k">void</span> <span class="n">DoWork2</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="k">lock</span> <span class="p">(</span><span class="n">lock2</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="p">{</span>        
</span></span><span class="line"><span class="cl">	    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;Thread 2 acquired lock2.&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">        <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">        <span class="k">lock</span> <span class="p">(</span><span class="n">lock1</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">        <span class="p">{</span>            
</span></span><span class="line"><span class="cl">	        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;Thread 2 acquired lock1.&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">        <span class="p">}</span>    
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在上面的代码中，定义了两个锁对象 <code>lock1</code> 和 <code>lock2</code>，然后创建了两个线程 <code>t1</code> 和 <code>t2</code>，分别在 <code>DoWork1</code> 和 <code>DoWork2</code> 方法中获取锁。然后在这两个方法中互相等待对方释放锁，导致程序陷入死锁状态。运行程序后，程序将无法继续执行下去，需要手动终止程序。为了避免死锁，我们需要使用合适的同步和互斥机制，避免线程之间的互相等待</p>
<blockquote>
<p><code>lock</code> 代码块是 C# 中用于实现线程同步的机制。<code>lock</code> 关键字可以将一段代码块标记为“临界区”，确保同一时刻只有一个线程可以进入这个代码块，从而避免多个线程同时访问共享资源，导致数据竞争和不确定性的问题，在上述示例中进入 <code>lock</code> 代码块之前，线程会尝试获取 <code>lock1</code> 的锁，如果这个锁当前没有被其他线程占用，那么线程将获取到锁，并进入临界区代码。在临界区代码执行完成之后，线程会释放锁，以便其他线程可以获取锁进入临界区</p>
</blockquote>
<p>也尽量减少使用 <code>Result</code> 或 <code>GetResult</code> 或 <code>Wait</code> 等方法（在某些地方适用，如控制台程序）</p>
<blockquote>
<p><code>Result</code> 属性为阻止属性。 如果你在其任务完成之前尝试访问它，当前处于活动状态的线程将被阻止，直到任务完成且值为可用。 在大多数情况下，应通过使用 <code>await</code> 访问此值，而不是直接访问属性</p>
</blockquote>
<p>该函数内容需要阻止主线程而等待新开的线程先完成，这可能会导致死锁，这正是我们试图避免使用异步和等待关键字的事情</p>
<h2 id="解决措施">解决措施</h2>
<ul>
<li>
<p>代码同步化，不争抢线程资源</p>
</li>
<li>
<p>不使用 <code>await</code> 关键字</p>
</li>
<li>
<p>使用  <code>ConfigureAwait()</code></p>
</li>
</ul>
<h1 id="上下文">上下文</h1>
<p>上下文（Context）是一种用于在不同线程之间共享数据的机制。上下文对象可以在一个线程中创建，并在另一个线程中使用，它可以是线程上下文、进程上下文、同步上下文、应用程序域上下文、执行上下文等等</p>
<p>指程序中当前执行代码的环境或状态。可以将上下文视为一个程序运行时的快照，其中包含了程序的当前状态、已定义的变量、对象以及正在执行的代码的位置等信息</p>
<h2 id="当前上下文">当前上下文</h2>
<p>通常也指异步上下文，它与线程池线程一起管理异步操作的执行。异步上下文是一种保存与异步操作相关的上下文信息的机制，包括线程 ID、SynchronizationContext 对象等。异步操作在等待其他操作完成时可能会保存当前上下文，以便可以在异步操作完成时恢复它。当前上下文与异步操作的执行是密切相关的，异步操作必须在正确的上下文中执行才能正常工作</p>
<h2 id="理解">理解</h2>
<ul>
<li>
<p>如果使用的是 UI 线程，那么就是 UI 上下文</p>
</li>
<li>
<p>如果使用的是 ASP.NET 请求响应，那么这就是 ASP.NET 请求上下文</p>
</li>
<li>
<p>其余情况都是线程池上下文</p>
</li>
</ul>
<p>当我们等待 <code>Task</code> 时，当等待决定暂停方法执行时，会捕获请求当前上下文。一旦方法准备好恢复执行，应用程序将从线程池中获取线程，将其分配给上下文，并恢复执行</p>
<p>在 ASP.NET Core 应用程序中没有<code> SynchronizationContext</code>。ASP.NET Core 避免捕获上下文并排队，它所做的只是从线程池中获取线程并将其分配给请求，因此，应用程序要做的后台工作要少得多</p>
<h2 id="示例">示例</h2>
<ol>
<li></li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// WinForms 示例程序(同样原理用于 WPF 程序).</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span> <span class="k">async</span> <span class="k">void</span> <span class="n">DownloadFileButton_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 因为我们使用了异步关键字 awiat，这个 UI 线程不会被文件下载阻止</span>
</span></span><span class="line"><span class="cl">  <span class="k">await</span> <span class="n">DownloadFileAsync</span><span class="p">(</span><span class="n">fileNameTextBox</span><span class="p">.</span><span class="n">Text</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 由于我们恢复了 UI 上下文，可以直接调用 UI 元素</span>
</span></span><span class="line"><span class="cl">  <span class="n">resultTextBox</span><span class="p">.</span><span class="n">Text</span> <span class="p">=</span> <span class="s">&#34;File downloaded!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="2">
<li></li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="n">button</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&#34;main1 thread {Thread.CurrentThread.ManagedThreadId}&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="n">TestConfigureAwait</span><span class="p">().</span><span class="n">Wait</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&#34;main2 thread: {Thread.CurrentThread.ManagedThreadId}&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span>  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="k">private</span> <span class="k">static</span> <span class="k">async</span> <span class="n">Task</span> <span class="n">TestConfigureAwait</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">Run</span><span class="p">(()</span> <span class="p">=&gt;</span>  
</span></span><span class="line"><span class="cl">    <span class="p">{</span>  
</span></span><span class="line"><span class="cl">        <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">6000</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&#34;task thread: {Thread.CurrentThread.ManagedThreadId}&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}).</span><span class="n">ConfigureAwait</span><span class="p">(</span><span class="k">false</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">     
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&#34;testConfigureAwait thread: {Thread.CurrentThread.ManagedThreadId}&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在这个示例中，是一个 UI 上下文内容，和使用了 <code>ConfigureAwait(false)</code> 来解决死锁问题</p>
<h1 id="异常捕获">异常捕获</h1>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Test</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="k">try</span>  
</span></span><span class="line"><span class="cl">    <span class="p">{</span>  
</span></span><span class="line"><span class="cl">        <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">SomeAsyncCode</span><span class="p">().</span><span class="n">Result</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}</span>    
</span></span><span class="line"><span class="cl">    <span class="k">catch</span> <span class="p">(</span><span class="n">ArgumentException</span> <span class="n">aex</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="p">{</span>        
</span></span><span class="line"><span class="cl">	    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&#34;Caught ArgumentException: {aex.Message}&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="k">private</span> <span class="k">static</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">SomeAsyncCode</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="n">Delay</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentException</span><span class="p">(</span><span class="s">&#34;Oh noes!&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在这个示例中我们尝试使用 <code>try-catch</code> 来捕捉异常，我们执行 <code>SomeAsyncCode()</code>，获取到它的 <code>Result</code> 属性。可以发现我们并没有进入到 <code>catch</code> 块。</p>
<p>这是因为，如果没有等待关键字，任务会吞噬异常。此外，不再有继续，操作也没有经过验证。如果继续执行此操作，将获得一个异常，但这将是映射异常，而不是我们从异步方法中抛出的异常</p>
<pre tabindex="0"><code class="language-log" data-lang="log">--- EXCEPTION #1/2 [ArgumentException]
</code></pre><p>在发生 ArgumentException 时，使用其他关键字尝试解决</p>
<p>在此示例，我们不能用 <code>await</code> 关键字来等待结果，我们使用 <code>SomeAsyncCode().GetAwaiter().GetResult()</code> 来捕捉，运行后结果正确，成功进入 <code>catch</code> 块</p>
<p>也可以使用 <a href="https://code-maze.com/global-error-handling-aspnetcore/">Global Error Handling</a> 技术来解决或跟踪异常</p>
<h1 id="控制台程序">控制台程序</h1>
<p>在 C# 7.1 之前其实是不能对控制台程序对主入口 <code>Main</code> 函数标记为 <code>async</code></p>
<h2 id="原因">原因</h2>
<p>如果 <code>await</code> 看到可等待项尚未完成，那么它会异步发挥作用。它告诉 awaitable 在方法完成后运行剩余部分，然后从异步方法返回。当将方法的剩余部分传递给 <code>await</code> 时，awaiter 还将捕获当前上下文</p>
<p>异步方法将在完成之前返回给其调用者。这在 UI 应用程序（方法仅返回 UI 事件循环）和 ASP.NET 应用程序（该方法从线程返回，但使请求保持保留状态）中完美工作</p>
<p>对于控制台程序来说效果不太好：<code>Main</code> 函数返回到操作系统，因此程序退出</p>
<h2 id="解决">解决</h2>
<p>控制台程序没有很大的必要使用异步，但为简单的一些操作演示，也是能解决的</p>
<p>让主线程强制等待异步完成，如以下示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">MainAsync</span><span class="p">(</span><span class="n">args</span><span class="p">).</span><span class="n">GetAwaiter</span><span class="p">().</span><span class="n">GetResult</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// or MainAsync(args).Wait()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="k">async</span> <span class="n">Task</span> <span class="n">MainAsync</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">Bootstrapper</span> <span class="n">bs</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Bootstrapper</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="kt">var</span> <span class="n">list</span> <span class="p">=</span> <span class="k">await</span> <span class="n">bs</span><span class="p">.</span><span class="n">GetList</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>主要就是 <code>GetAwaiter</code> 方法和 <code>GetResult</code> 方法，前者是获取到有 <code>Task</code> 标记的异步程序，后者是等待此有 <code>Task</code> 标记的异步程序结束</p>
<p>也可以直接使用 <code>MainAsync(args).Wait()</code>，<code>Wait</code> 方法与上面类似，但上面的两个方法会避免一些 <code>AggregateException</code> 包装错误</p>
<h1 id="总结-1">总结</h1>
<p>以上内容为搜罗实验整理，如有错误欢迎留言指正交流，如有内容变动会及时更新</p>
<p>更多参考：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>Old</strong></th>
<th style="text-align:center"><strong>New</strong></th>
<th style="text-align:center"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">task.Wait</td>
<td style="text-align:center">await task</td>
<td style="text-align:center">Wait/await for a task to complete</td>
</tr>
<tr>
<td style="text-align:center">task.Result</td>
<td style="text-align:center">await task</td>
<td style="text-align:center">Get the result of a completed task</td>
</tr>
<tr>
<td style="text-align:center">Task.WaitAny</td>
<td style="text-align:center">await Task.WhenAny</td>
<td style="text-align:center">Wait/await for one of a collection of tasks to complete</td>
</tr>
<tr>
<td style="text-align:center">Task.WaitAll</td>
<td style="text-align:center">await Task.WhenAll</td>
<td style="text-align:center">Wait/await for every one of a collection of tasks to complete</td>
</tr>
<tr>
<td style="text-align:center">Thread.Sleep</td>
<td style="text-align:center">await Task.Delay</td>
<td style="text-align:center">Wait/await for a period of time</td>
</tr>
<tr>
<td style="text-align:center">Task constructor</td>
<td style="text-align:center">Task.Run or TaskFactory.StartNew</td>
<td style="text-align:center">Create a code-based task</td>
</tr>
</tbody>
</table>
<ul>
<li><a href="https://stackoverflow.com/questions/9343594/how-to-call-asynchronous-method-from-synchronous-method-in-c">How to call asynchronous method from synchronous method in C#?</a></li>
<li><a href="https://blog.stephencleary.com/2014/04/a-tour-of-task-part-0-overview.html">A Tour of Task</a></li>
<li><a href="https://blog.stephencleary.com/2012/02/async-and-await.html#comments">Async and Await</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>线程</title>
      <link>https://brealinhub.com/posts/%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Fri, 03 Mar 2023 16:21:40 +0000</pubDate>
      
      <guid>https://brealinhub.com/posts/%E7%BA%BF%E7%A8%8B/</guid>
      <description>Threads 定义 线程被定义为程序的执行路径。每个线程定义了一个唯一的控制流，如果应用程序涉及复杂而耗时的操作，那么设置不同的执行路径或线程通常很有帮助，每个线程执行特定的工作
线程是轻量级过程。使用线程的一个常见例子是现代操作系统实现并发编程。使用线程可以节省 CPU 周期的浪费，并提高应用程序的效率
Thread 对象代表了一个线程的执行状态和行为，它可以直接创建和管理线程。线程是操作系统调度的最小执行单位，一个进程可以包含多个线程，线程之间可以并行执行，但需要注意线程安全的问题。开发人员需要手动控制线程的生命周期、线程的同步和互斥等问题，否则容易引起线程竞争、死锁等问题
在 .Net Framework 4.0 之前都是都是用 Thread 类来进行操作并发编程，此类实例表示操作系统内部调度的托管线程
创建实例 public static void Main() { double i = 0; var t = new Thread(() =&amp;gt; { i = Math.Exp(1); }); // Math.Exp() 中的 e 是欧拉数，常数大约为 2.71828，记作 e 的 d 次方 t.Start();// 启动线程 t.Join();// 会等待目标线程结束，将值传回 i Console.WriteLine(i); // output: 2.718281828459045 } 这里我们演示了一遍创建子线程操作，思考一下，如果我们频繁对一些操作处理要开线程的话，其加载初始化对操作系统的负载未免加大
这时，微软在 CLR 引入了线程池和其中的可配置线程池参数，线程池不包含线程，只有当需要用到时，才会按需创建，并当线程完成时不会立即销毁而会以暂停状态返回线程池，会保留一段时间直至唤醒，长时间不使用则会销毁
管理 可用 Thread.Sleep(int millisecondsTimeout) 方法来暂停主线程
销毁 以前可见 Abort() 销毁方法，但在 .Net 5.</description>
      <content:encoded><![CDATA[<h2 id="threads">Threads</h2>
<h3 id="定义">定义</h3>
<ul>
<li>
<p><strong>线程</strong>被定义为程序的执行路径。每个线程定义了一个唯一的控制流，如果应用程序涉及复杂而耗时的操作，那么设置不同的执行路径或线程通常很有帮助，每个线程执行特定的工作</p>
</li>
<li>
<p>线程是<strong>轻量级过程</strong>。使用线程的一个常见例子是现代操作系统实现<strong>并发</strong>编程。使用线程可以节省 CPU 周期的浪费，并提高应用程序的效率</p>
</li>
<li>
<p><code>Thread</code> 对象代表了一个<strong>线程</strong>的执行状态和行为，它可以直接创建和管理线程。线程是操作系统调度的最小执行单位，一个进程可以包含多个线程，线程之间可以并行执行，但需要注意线程安全的问题。开发人员需要手动控制线程的生命周期、线程的同步和互斥等问题，否则容易引起线程竞争、死锁等问题</p>
</li>
</ul>
<p>在 .Net Framework 4.0 之前都是都是用 <code>Thread</code> 类来进行操作并发编程，此类实例表示操作系统内部调度的托管线程</p>
<h3 id="创建实例">创建实例</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="n">i</span> <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">Exp</span><span class="p">(</span><span class="m">1</span><span class="p">);</span> <span class="p">});</span>   
</span></span><span class="line"><span class="cl">    <span class="c1">// Math.Exp() 中的 e 是欧拉数，常数大约为 2.71828，记作 e 的 d 次方  </span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span><span class="c1">// 启动线程  </span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">Join</span><span class="p">();</span><span class="c1">// 会等待目标线程结束，将值传回 i  </span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// output: 2.718281828459045</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这里我们演示了一遍创建子线程操作，思考一下，如果我们频繁对一些操作处理要开线程的话，其加载初始化对操作系统的负载未免加大</p>
<p>这时，微软在 <a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E8%AA%9E%E8%A8%80%E9%81%8B%E8%A1%8C%E5%BA%AB">CLR</a> 引入了线程池和其中的可配置<strong>线程池</strong>参数，线程池不包含线程，只有当需要用到时，才会按需创建，并当线程完成时不会立即销毁而会以暂停状态返回线程池，会保留一段时间直至唤醒，长时间不使用则会销毁</p>
<h4 id="管理">管理</h4>
<p>可用 <code>Thread.Sleep(int millisecondsTimeout)</code> 方法来暂停主线程</p>
<h4 id="销毁">销毁</h4>
<p>以前可见 <code>Abort()</code> 销毁方法，但在 .Net 5.0 之后被列为过时方法</p>
<p>原因：不知道被销毁的线程哪些代码被执行或未执行，比如调用 <code>Thread.Abort</code> 可能会阻止静态构造函数的执行或托管或非托管资源的发布</p>
<p>如果强行使用此方法，会报出 <code>Abort is not supported on this platform</code> 错误，也可以屏蔽此错误以使用，例如</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="cp">#pragma warning disable SYSLIB0006 </span>
</span></span><span class="line"><span class="cl"><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">Abort</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl"><span class="cp">#pragma warning restore SYSLIB0006</span>
</span></span></code></pre></div><p>但建议使用 <code>CancellationTokenSource</code> 类进行线程的销毁</p>
<p>示例：</p>
<p>in <code>CancellationTest.cs</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建取消令牌源实例</span>
</span></span><span class="line"><span class="cl">    <span class="n">CancellationTokenSource</span> <span class="n">cts</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CancellationTokenSource</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;In Main: Creating the BackThreadsPool&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="c1">// 第二个参数传入实例令牌</span>
</span></span><span class="line"><span class="cl">    <span class="n">ThreadPool</span><span class="p">.</span><span class="n">QueueUserWorkItem</span><span class="p">(</span><span class="n">CallToChildThread</span><span class="p">,</span> <span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1500</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">	<span class="c1">// 发出实例取消请求</span>
</span></span><span class="line"><span class="cl">    <span class="n">cts</span><span class="p">.</span><span class="n">Cancel</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl">    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;Thread Termination!&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="c1">// 回收</span>
</span></span><span class="line"><span class="cl">    <span class="n">cts</span><span class="p">.</span><span class="n">Dispose</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="k">void</span> <span class="n">CallToChildThread</span><span class="p">(</span><span class="kt">object?</span> <span class="n">i</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="k">try</span>  
</span></span><span class="line"><span class="cl">    <span class="p">{</span>  
</span></span><span class="line"><span class="cl">	    <span class="c1">// 创建取消令牌实例</span>
</span></span><span class="line"><span class="cl">        <span class="n">CancellationToken</span> <span class="n">token</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CancellationToken</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl">        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;Child thread starts&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">counter</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">counter</span> <span class="p">&lt;=</span> <span class="m">10</span><span class="p">;</span> <span class="n">counter</span><span class="p">++)</span>  
</span></span><span class="line"><span class="cl">        <span class="p">{</span>            
</span></span><span class="line"><span class="cl">	        <span class="k">if</span> <span class="p">(!</span><span class="n">token</span><span class="p">.</span><span class="n">IsCancellationRequested</span><span class="p">)</span>  <span class="c1">// 判断取消令牌是否发出请求</span>
</span></span><span class="line"><span class="cl">	        <span class="p">{</span>               
</span></span><span class="line"><span class="cl">	             <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">500</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">	             <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">counter</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">            <span class="p">}</span>        
</span></span><span class="line"><span class="cl">	    <span class="p">}</span>        
</span></span><span class="line"><span class="cl">        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;Child Thread Completed&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="p">}</span>    
</span></span><span class="line"><span class="cl">    <span class="k">catch</span> <span class="p">(</span><span class="n">ThreadAbortException</span> <span class="n">e</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">    <span class="p">{</span>        
</span></span><span class="line"><span class="cl">	    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;Thread Abort Exception&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}</span>    
</span></span><span class="line"><span class="cl">    <span class="k">finally</span>  
</span></span><span class="line"><span class="cl">    <span class="p">{</span>  
</span></span><span class="line"><span class="cl">        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;Couldn&#39;t catch the Thread Exception&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//output: </span>
</span></span><span class="line"><span class="cl"><span class="c1">//0</span>
</span></span><span class="line"><span class="cl"><span class="c1">//1</span>
</span></span><span class="line"><span class="cl"><span class="c1">//2</span>
</span></span><span class="line"><span class="cl"><span class="c1">//Thread Termination!</span>
</span></span></code></pre></div><p>感觉用了 <code>token</code> 令牌管理，更方便内容规划</p>
<p>注意：因为该类继承了 <code>IDisposable</code> 接口，所以必须调用 <code>CancellationTokenSource.Dispose </code> 方法，以释放它拥有的任何非托管资源</p>
<h3 id="后台线程">后台线程</h3>
<p>后台线程（Background thread）是指不会阻止程序终止的线程，即使后台线程仍在运行，程序也可以正常退出。与之相对的是前台线程（Foreground thread），前台线程是指会阻止程序终止的线程，只有所有前台线程都结束了，程序才会正常退出</p>
<p>后台线程通常用于执行一些较为耗时的任务，如文件下载、数据处理、网络通信等。通过将这些任务放在后台线程中执行，可以避免阻塞程序的主线程，从而提高程序的响应性</p>
<p>代码示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">System.Threading</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Program</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl">	<span class="p">{</span>  
</span></span><span class="line"><span class="cl">	    <span class="n">Thread</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">(</span><span class="n">DoWork</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">		<span class="p">{</span>        
</span></span><span class="line"><span class="cl">		    <span class="n">IsBackground</span> <span class="p">=</span> <span class="k">true</span> <span class="c1">// 设置为后台线程  </span>
</span></span><span class="line"><span class="cl">	    <span class="p">};</span>  
</span></span><span class="line"><span class="cl">	    <span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">	    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;Main thread exit.&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">	<span class="p">}</span>  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">	<span class="k">static</span> <span class="k">void</span> <span class="n">DoWork</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl">	<span class="p">{</span>  
</span></span><span class="line"><span class="cl">	    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;Background thread start.&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">	    <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">5000</span><span class="p">);</span> <span class="c1">// 模拟耗时操作  </span>
</span></span><span class="line"><span class="cl">	    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;Background thread exit.&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>此示例创建了一个线程并设置为后台线程，即使主线程已经退出，该线程仍然可以继续运行。如果将线程设置为前台线程，则主线程必须等待该线程执行完毕才能退出</p>
<h3 id="线程池">线程池</h3>
<p>在 <code>TreadPool</code> 类下，其下有许多可配置线程内容</p>
<p>线程池使用后台线程，如果所有前台线程都已终止，则不会使应用程序保持运行</p>
<h4 id="一些用法">一些用法</h4>
<ul>
<li>
<p><code>ThreadPool.QueueUserWorkItem(WaitCallback callBack, object? state)</code></p>
<p>在线程池队列添加实现内容，注意内容是 <code>WaitCallback(Object?)</code> 类型回调</p>
</li>
<li>
<p><code>ThreadPool.GetAvailableThreads(out int workerThreads, out int completionPortThreads)</code></p>
<p>获取当前可用的线程和 I/O 线程</p>
</li>
<li>
<p><code>ThreadPool.GetMinThreads()</code> or <code>GetMaxThreads()</code></p>
<p>按需创建 最小/最大 线程数</p>
</li>
</ul>
<p>等等</p>
<h4 id="问题">问题</h4>
<p>示例如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">exp1</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">mres</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ManualResetEventSlim</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ThreadPool</span><span class="p">.</span><span class="n">QueueUserWorkItem</span><span class="p">&lt;</span><span class="n">ManualResetEventSlim</span><span class="p">&gt;((</span><span class="n">_mres</span><span class="p">)</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">exp1</span> <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">Exp</span><span class="p">(</span><span class="m">40</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">mres</span><span class="p">.</span><span class="n">Set</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">},</span> <span class="n">mres</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">mres</span><span class="p">.</span><span class="n">Wait</span><span class="p">();</span>
</span></span></code></pre></div><p><code>ManualResetEventSlim</code> 类是一个轻量的物体，工作原理有点像发出信号，比如上述代码内容，<code>mres</code> 实例有 <code>Set</code> 和 <code>Wait</code> 两种方法，<code>Wait</code> 方法要等到线程中发出的 <code>Set</code> 信号才能执行</p>
<p>这种线程池无法知道第一个参数委托何时能够完成，无法知道线程状态，且代码量更大更复杂时不太好用这种方法管理</p>
<p>所以 <code>Task</code> 出生以解决这类问题</p>
<h3 id="线程切换">线程切换</h3>
<p>线程切换是指 CPU 从一个线程切换到另一个线程执行的过程。线程切换在多任务操作系统中是必不可少的，因为操作系统需要分配 CPU 时间片来运行不同的线程，从而实现并发执行</p>
<p>但线程切换会带来下面的问题：</p>
<ol>
<li>
<p>性能开销：线程切换需要进行一些上下文切换的操作，包括保存和恢复线程的上下文信息，这些操作会带来一定的性能开销。</p>
</li>
<li>
<p>竞态条件：线程切换可能导致竞态条件，即多个线程访问共享资源时的不确定性和冲突问题，从而可能导致死锁、活锁等问题。</p>
</li>
<li>
<p>缓存失效：当线程切换时，CPU需要切换到另一个线程的上下文中，这可能导致缓存失效，从而影响系统的性能</p>
</li>
</ol>
<p>解决措施就是使用减少线程、优化算法、使用异步编程</p>
<h3 id="结果">结果</h3>
<h4 id="更多">更多</h4>
<p>关于任务，还有很多没有探索，任务经过优化，可以在线程池线程上工作，每个任务都有其本地队列</p>
<p>我们没有讨论子任务，它利用了本地队列的数据位置，任务类还包含启发式方法，以便能够找到执行我们任务的最佳方式</p>
<h4 id="总结例子">总结例子</h4>
<p>在以上所举的例子都是 <code>Task</code> 方法更简洁优雅，不用令牌取消（在 Unity 中需要注意），也方便销毁等等，<code>Task</code> 也是下面[[异步]]编程的核心</p>
<p>那 <code>Thread</code> 类就没有用吗？</p>
<p>不是的，实际 <code>Thread</code> 能用到且高效的地方比较少，用例如下</p>
<ul>
<li>
<p>当我们需要前台执行某些代码时，我们必须使用 <code>Thread</code>，<code>Task</code> 总是在后台线程上运行，这不会阻止应用程序退出</p>
</li>
<li>
<p>当 <code>Thread</code> 具有特定优先级时，选择本机线程是合理的。在创建过程中，可以通过指定自定义调度程序来间接更改 <code>Task</code> 优先级。实现 <code>Task</code> 调度程序并不总是值得的，这就是为什么产生一个新线程通常是最好的选择</p>
</li>
<li>
<p><code>Thread</code> 具有关联的稳定身份。这在调试时很有用，因为我们可以知道将执行代码的线程的身份。<code>Task</code> 默认情况下在线程池线程上运行，但是我们已经看到这是可配置的。长时间运行的 <code>Task</code> 有其专用线程，因此，在这种情况下，<code>Task</code> 更有用</p>
</li>
</ul>
<h2 id="总结">总结</h2>
<p>以上内容为搜罗试验整理，如果整合不准确或有错误欢迎留言指正！</p>
<p>虽然更多为笔记向但也希望对你能有帮助，如果后续内容有修改增添会及时更新&hellip;</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
