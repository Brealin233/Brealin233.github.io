<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Unity on brealinblog</title>
    <link>https://brealinhub.com/tags/unity/</link>
    <description>Recent content in Unity on brealinblog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 07 Apr 2023 14:00:01 +0000</lastBuildDate><atom:link href="https://brealinhub.com/tags/unity/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Unity 性能优化 Chapter3</title>
      <link>https://brealinhub.com/posts/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-chapter3/</link>
      <pubDate>Fri, 07 Apr 2023 14:00:01 +0000</pubDate>
      
      <guid>https://brealinhub.com/posts/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-chapter3/</guid>
      <description>性能优化问题的本质 慢与快的问题
前提
稳定性：不能因优化造成稳定性变差
兼容性：不能因优化导致兼容性变差
性价比：优化要有度，考虑成本与复杂度
性能优化的流程 发现问题（什么平台、什么操作系统、什么情况下出现问题，一般问题还是特例问题等） 定位问题（什么地方造成的性能问题，我们要用什么工具、什么方法确定瓶颈） 研究问题（确定用什么方案处理这个问题，要考虑性能优化的前提） 解决问题（按问题研究的结论去实际处理，并验证处理结果与预期的一致性） 影响性能的问题 CPU 通常，CPU 渲染时间的最大贡献者是向 GPU 发送渲染命令的成本。渲染命令包括绘制调用（绘制几何形状的命令），以及在绘制几何形状之前更改 GPU 上设置的命令
减少 Unity 渲染的对象数量 考虑减少场景中对象的总数，例如：使用 skybox 来创建遥远几何的效果 执行更严格的剔除，以便 Unity 绘制更少的对象。考虑使用遮挡剔除来防止 Unity 绘制隐藏在其他物体后面的物体，减少相机的远夹平面，以便更远的物体落在其果实之外，或者，对于更细粒度的方法，将物体放入单独的层，并使用 Camera.layerCullDistances 设置每层剔除距离 减少 Unity 渲染每个对象的次数 在适当的情况下，使用 light mapping 来烘焙（预计算）照明和阴影。这增加了构建时间、运行时内存使用和存储空间，但可以提高运行时性能 如果应用程序使用 Forward rendering，请减少影响对象的每像素实时灯光的数量 实时阴影可能是非常资源密集型，因此请谨慎而高效地使用它们 如果应用程序使用反射探针，请确保您优化其使用 GPU 填充率的限制 GPU 试图每帧绘制的像素比它所能处理的要多，如果是这种情况，请考虑以下选项：
识别并减少应用程序中的透支。透支最常见的贡献者是重叠的透明元素，如 UI、粒子和 Sprite，在 Unity 编辑器中，使用 Overdraw Draw模式 来识别有问题的区域 降低片段着色器的执行成本 如果您使用的是 Unity 的内置着色器，请从 Mobile 或 Unlit 类别中选择一个。它们也适用于非移动平台，但它们是更复杂的着色器的简化和近似版本 动态分辨率是一个 Unity 功能，允许您动态缩放单个渲染目标 内存带宽的限制 GPU 正在尝试向其专用内存读取和写入比它在帧中可以处理的更多数据。这通常意味着有太多的纹理，或者纹理太大。如果是这种情况，请考虑以下选项：</description>
      <content:encoded><![CDATA[<h2 id="性能优化问题的本质">性能优化问题的本质</h2>
<ul>
<li>
<p>慢与快的问题</p>
</li>
<li>
<p>前提</p>
<ul>
<li>
<p>稳定性：不能因优化造成稳定性变差</p>
</li>
<li>
<p>兼容性：不能因优化导致兼容性变差</p>
</li>
<li>
<p>性价比：优化要有度，考虑成本与复杂度</p>
</li>
</ul>
</li>
</ul>
<h2 id="性能优化的流程">性能优化的流程</h2>
<ol>
<li>发现问题（什么平台、什么操作系统、什么情况下出现问题，一般问题还是特例问题等）</li>
<li>定位问题（什么地方造成的性能问题，我们要用什么工具、什么方法确定瓶颈）</li>
<li>研究问题（确定用什么方案处理这个问题，要考虑性能优化的前提）</li>
<li>解决问题（按问题研究的结论去实际处理，并验证处理结果与预期的一致性）</li>
</ol>
<h2 id="影响性能的问题">影响性能的问题</h2>
<h3 id="cpu">CPU</h3>
<p>通常，CPU 渲染时间的最大贡献者是向 GPU 发送渲染命令的成本。渲染命令包括绘制调用（绘制几何形状的命令），以及在绘制几何形状之前更改 GPU 上设置的命令</p>
<h4 id="减少-unity-渲染的对象数量">减少 Unity 渲染的对象数量</h4>
<ul>
<li>考虑减少场景中对象的总数，例如：使用 skybox 来创建遥远几何的效果</li>
<li>执行更严格的剔除，以便 Unity 绘制更少的对象。考虑使用遮挡剔除来防止 Unity 绘制隐藏在其他物体后面的物体，减少相机的远夹平面，以便更远的物体落在其果实之外，或者，对于更细粒度的方法，将物体放入单独的层，并使用 <a href="https://docs.unity3d.com/cn/2021.3/ScriptReference/Camera-layerCullDistances.html">Camera.layerCullDistances</a> 设置每层剔除距离</li>
</ul>
<h4 id="减少-unity-渲染每个对象的次数">减少 Unity 渲染每个对象的次数</h4>
<ul>
<li>在适当的情况下，使用 <a href="https://docs.unity3d.com/cn/2021.3/Manual/Lightmappers.html">light mapping</a> 来烘焙（预计算）照明和阴影。这增加了构建时间、运行时内存使用和存储空间，但可以提高运行时性能</li>
<li>如果应用程序使用 Forward rendering，请减少影响对象的每像素实时灯光的数量</li>
<li>实时阴影可能是非常资源密集型，因此请谨慎而高效地使用它们</li>
<li>如果应用程序使用反射探针，请确保您优化其使用</li>
</ul>
<h3 id="gpu">GPU</h3>
<h4 id="填充率的限制">填充率的限制</h4>
<p>GPU 试图每帧绘制的像素比它所能处理的要多，如果是这种情况，请考虑以下选项：</p>
<ul>
<li>识别并减少应用程序中的透支。透支最常见的贡献者是重叠的透明元素，如 UI、粒子和 Sprite，在 Unity 编辑器中，使用 <a href="https://docs.unity3d.com/cn/2021.3/Manual/ViewModes.html">Overdraw Draw模式</a> 来识别有问题的区域</li>
<li>降低片段着色器的执行成本</li>
<li>如果您使用的是 Unity 的内置着色器，请从 Mobile 或 Unlit 类别中选择一个。它们也适用于非移动平台，但它们是更复杂的着色器的简化和近似版本</li>
<li>动态分辨率是一个 Unity 功能，允许您动态缩放单个渲染目标</li>
</ul>
<h4 id="内存带宽的限制">内存带宽的限制</h4>
<p>GPU 正在尝试向其专用内存读取和写入比它在帧中可以处理的更多数据。这通常意味着有太多的纹理，或者纹理太大。如果是这种情况，请考虑以下选项：</p>
<ul>
<li>为与相机距离在运行时变化的纹理启用 mipmap（例如，3D场景中使用的大多数纹理），这增加了这些纹理的内存使用量和存储空间，但可以提高运行时 GPU 的性能</li>
<li>使用合适的压缩格式来减小内存中纹理的大小。这可能会导致更快的加载时间、更小的内存占用和更高的 GPU 渲染性能。压缩纹理仅使用未压缩纹理所需的内存带宽的一小部分</li>
</ul>
<h4 id="顶点处理的限制">顶点处理的限制</h4>
<p>这意味着GPU正在尝试处理比它在帧中处理的更多的顶点。如果是这种情况，请考虑以下选项：</p>
<ul>
<li>降低顶点着色器的执行成本</li>
<li>优化您的几何形状：不要使用不必要的三角形，并尽量保持紫外线映射接缝和硬边（加倍顶点）的数量</li>
<li>使用 Level of Detail 系统</li>
</ul>
<h3 id="降低渲染频率">降低渲染频率</h3>
<p>有时，降低渲染帧速率可能会使应用程序受益，这不会降低渲染单个帧的 CPU 或 GPU 成本，但它减少了 Unity 这样做的频率，而不会影响其他操作（如脚本执行）的频率</p>
<p>可以降低应用程序部分或整个应用程序的渲染帧速率。降低渲染帧速率，以防止不必要的电力使用，延长电池寿命，并防止设备温度上升到 CPU 频率可能受到限制的程度。这在手持设备上特别有用</p>
<h3 id="隐藏的几类小问题">隐藏的几类小问题</h3>
<ul>
<li>功耗比</li>
<li>填充率</li>
<li>发热量</li>
</ul>
<h2 id="性能问题可能的情况">性能问题可能的情况</h2>
<ul>
<li>瓶颈可能性按由高到低的顺序排列（UP 经验总结）
<ul>
<li>CPU 利用率</li>
<li>带宽利用率</li>
<li>CPU / GPU 强制同步</li>
<li>片元着色器指令</li>
<li>几何图形到 CPU 到 GPU 的传输</li>
<li>纹理 CPU 到 GPU 的传输</li>
<li>顶点着色器指令</li>
<li>几何图形复杂性</li>
</ul>
</li>
</ul>
<h2 id="经常用的优化思路">经常用的优化思路</h2>
<ul>
<li>升维与降维</li>
</ul>
<p>升维：优化性能，但算法不易理解
降维：算法容易理解，但性能优化差</p>
<ul>
<li>维度转换，如空间与时间、量纲转换</li>
</ul>
<p>{%note primary%}</p>
<h3 id="aos-and-soa">AoS and SoA</h3>
<p>结构数组（AoS），数组结构（SoA）或数组结构数组（AoSoA）是排列内存中记录序列的对比方法，涉及交错，并且对 <a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data">SIMD</a> 和 SIMT 编程有关</p>
<p>标准 C# 数组是 AoS，但 SoA 的结构适用于使用 CPU 缓存，CPU 缓存比主内存快，以及 SIMD 的超快速并行处理</p>
<h4 id="aos">AoS</h4>
<p>面向对象思想，不同字段的数据在其中交错，这通常更直观，并由大多数编程语言直接支持</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">-----------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">| double | int | char | *pad* | double | int | char | *pad* | double | int | char |
</span></span><span class="line"><span class="cl">-----------------------------------------------------------------------------
</span></span></code></pre></div><h4 id="soa">SoA</h4>
<p>面向数据思想，将记录的元素（或 C 编程语言中的“结构”）分离成每个字段一个并行数组。在大多数指令集架构中，使用打包的 SIMD 指令更容易操作，因为单个 SIMD 寄存器可以加载同质数据，可能由广泛的内部数据路径（例如128位）传输</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">-----------------------------------------------------------------------------
</span></span><span class="line"><span class="cl">| double | double | double | *pad* | int | int | int | *pad* | char | char | char |
</span></span><span class="line"><span class="cl">-----------------------------------------------------------------------------
</span></span></code></pre></div><p>如果只需要记录的特定部分，则只需要迭代这些部分，允许将更多数据放入单个缓存行中。缺点是遍历数据时需要更多的缓存方式，以及低效的索引寻址</p>
<h4 id="差异">差异</h4>
<ol>
<li>
<p>由于每个对象都保存在一起，因此 AoS 对程序员来说更容易阅读</p>
</li>
<li>
<p>如果结构的所有成员一起访问，AoS 可能会有更好的缓存位置</p>
</li>
<li>
<p>SoA 可能更有效率，因为将相同的数据类型组合在一起有时会暴露矢量化</p>
</li>
<li>
<p>在许多情况下，SoA 使用的内存较少，因为填充仅在数组之间，而不是在每个结构之间</p>
</li>
</ol>
<h3 id="structureofarraysgenerator">StructureOfArraysGenerator</h3>
<p>Structure of arrays source generator 插件制造 CPU 缓存和 SIMD 友好的数据结构制造高性能代码用于 .NET 和 Unity 平台</p>
<p><a href="https://user-images.githubusercontent.com/46207/214814782-fd341e09-731a-4e2f-ba53-ef789a19160e.png">
  <img loading="lazy" src="https://user-images.githubusercontent.com/46207/214814782-fd341e09-731a-4e2f-ba53-ef789a19160e.png" alt="principle"  /></a></p>
<p>点击<a href="(https://github.com/Cysharp/StructureOfArraysGenerator)"><strong>链接</strong></a>以了解更多</p>
<p>{%endnote%}</p>
<h2 id="参考">参考</h2>
<ul>
<li>
<p><a href="https://learn.unity.com/tutorial/fixing-performance-problems-2019-3-1#">Fixing Performance Problems - 2019.3</a></p>
</li>
<li>
<p><a href="https://docs.unity3d.com/cn/2021.3/Manual/OptimizingGraphicsPerformance.html">Graphics performance fundamentals</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Unity 性能优化 Chapter2</title>
      <link>https://brealinhub.com/posts/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-chapter2/</link>
      <pubDate>Fri, 31 Mar 2023 14:25:07 +0000</pubDate>
      
      <guid>https://brealinhub.com/posts/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-chapter2/</guid>
      <description>静态优化 Import Unity 工程目录结构及用途 Asset 这是存储所有游戏资源的文件夹，包括脚本、纹理、声音和自定义编辑器脚本。文件夹的组织可能因项目而异，因组织而异。资产文件夹中可以有许多子文件夹，具体取决于项目的组织方式。例如，可能有一个用于场景的文件夹，一个用于脚本，一个用于音频，或者一个用于 Sprite，组织有多深是没有限制的
{% note primary %}
Unity 在 Assets 文件夹下保留了几个特殊文件夹名称。这些文件夹是编辑器、编辑器默认资源、Gizmos、资源、标准资产和流资产，并非每个项目都有所有这些文件夹
Assets / Editor：此文件夹用于扩展 Unity 编辑器功能的自定义编辑器脚本。这些脚本将在编辑器中运行，但在运行时不会在项目中运行。资产文件夹中可以存在多个编辑器文件夹，编辑器脚本的执行方式因编辑器文件在文件夹结构中的位置而异。
Assets / Editor Default Resources： 这是存储编辑器脚本使用的资产文件的地方。只能有一个这样的文件夹，它必须放在资产文件夹根目录中，此文件夹中可能有子文件夹
Assets / Gizmos： Gizmos 是场景视图中的图形，可以帮助可视化设计细节。此文件夹存储用于小发明的图像，只能有一个文件夹，它必须放在资产文件夹根目录中
Assets / Resources：此文件夹存储资源，以便在 Unity 项目中按需加载。可以有多个资源文件夹。按需加载有助于动态加载在设计期间没有设计师创建的实例的游戏对象。换句话说，这些资源在设计时可能没有在场景中放置相应的游戏对象，并在运行时动态加载，但现在都使用 Assets Bundle 构建
Assets / Standard Assets ：此文件夹存储已导入项目的任何标准资产包。脚本编译优先级最高，只能有一个标准资产文件夹。标准资产是由 Unity 维护的免费资产
Assets / Streaming Assets ： 此文件夹用于保留其原始格式的资产，然后流式传输到 Unity 应用程序中，而不是直接将其纳入项目的构建中。一个例子是来自文件系统的视频文件。项目中只能有 1 个流媒体资产文件夹
{% endnote %}
Library 用来存储项目内部资产数据信息的目录，即 Unity 用于导入资产的本地缓存。它可以被删除，并将由 Unity 自动重新生成，重新创建文件夹所需的只是 Assets 文件夹 和 .meta 文件。如果此文件夹被删除，Unity 将重新导入所有资产，并在下次在编辑器中打开项目时重新生成文件夹。此文件夹不应包含在版本控制中，Unity 使用这些导入的资产来节省 Unity 运行时的时间</description>
      <content:encoded><![CDATA[<h1 id="静态优化">静态优化</h1>
<h2 id="import">Import</h2>
<h3 id="unity-工程目录结构及用途">Unity 工程目录结构及用途</h3>
<h4 id="asset">Asset</h4>
<p>这是存储所有游戏资源的文件夹，包括脚本、纹理、声音和自定义编辑器脚本。文件夹的组织可能因项目而异，因组织而异。资产文件夹中可以有许多子文件夹，具体取决于项目的组织方式。例如，可能有一个用于场景的文件夹，一个用于脚本，一个用于音频，或者一个用于 Sprite，组织有多深是没有限制的</p>
<p>{% note primary %}</p>
<p>Unity 在 Assets 文件夹下保留了几个特殊文件夹名称。这些文件夹是编辑器、编辑器默认资源、Gizmos、资源、标准资产和流资产，并非每个项目都有所有这些文件夹</p>
<p><strong>Assets / Editor</strong>：此文件夹用于扩展 Unity 编辑器功能的自定义编辑器脚本。这些脚本将在编辑器中运行，但在运行时不会在项目中运行。资产文件夹中可以存在多个编辑器文件夹，编辑器脚本的执行方式因编辑器文件在文件夹结构中的位置而异。</p>
<p><strong>Assets / Editor Default Resources</strong>： 这是存储编辑器脚本使用的资产文件的地方。只能有一个这样的文件夹，它必须放在资产文件夹根目录中，此文件夹中可能有子文件夹</p>
<p><strong>Assets / Gizmos</strong>： Gizmos 是场景视图中的图形，可以帮助可视化设计细节。此文件夹存储用于小发明的图像，只能有一个文件夹，它必须放在资产文件夹根目录中</p>
<p><strong>Assets / Resources</strong>：此文件夹存储资源，以便在 Unity 项目中按需加载。可以有多个资源文件夹。按需加载有助于动态加载在设计期间没有设计师创建的实例的游戏对象。换句话说，这些资源在设计时可能没有在场景中放置相应的游戏对象，并在运行时动态加载，但<strong>现在都使用 Assets Bundle 构建</strong></p>
<p><strong>Assets / Standard Assets</strong> ：此文件夹存储已导入项目的任何标准资产包。脚本编译优先级最高，只能有一个标准资产文件夹。标准资产是由 Unity 维护的免费资产</p>
<p><strong>Assets / Streaming Assets</strong> ： 此文件夹用于保留其原始格式的资产，然后流式传输到 Unity 应用程序中，而不是直接将其纳入项目的构建中。一个例子是来自文件系统的视频文件。项目中只能有 1 个流媒体资产文件夹</p>
<p>{% endnote %}</p>
<h4 id="library">Library</h4>
<p>用来存储项目内部资产数据信息的目录，即 Unity 用于导入资产的本地缓存。它可以被删除，并将由 Unity 自动重新生成，重新创建文件夹所需的只是 <strong>Assets 文件夹</strong> 和 <strong><code>.meta</code></strong> 文件。如果此文件夹被删除，Unity 将重新导入所有资产，并在下次在编辑器中打开项目时重新生成文件夹。此文件夹不应包含在版本控制中，Unity 使用这些导入的资产来节省 Unity 运行时的时间</p>
<p>库文件夹中特别值得注意的是软件包缓存文件夹。这包含有关当前项目安装的所有软件包的信息。虽然这可以像库文件夹中的其他项目一样由 Unity 重新生成，但出于存档目的，重要的是不要删除此文件。这是因为能够查看项目中包含哪些软件包可能会有所帮助，而无需重新生成缓存，这需要以适当的编辑器版本打开项目</p>
<h4 id="packages">Packages</h4>
<p>用来存储项目的包文件信息，此文件夹包含 JSON 格式的清单文件，用于维护软件包之间的依赖项链接。它还包含一个文件，其中列出了与项目一起安装的单个软件包。这些由 Unity 软件包管理器使用。软件包管理器已添加到 Unity 2018.1 中。在这些情况下，先前版本的 Unity 将不包含软件包管理器，并且软件包文件夹将不存在</p>
<h4 id="project-settings">Project Settings</h4>
<p>用来存储项目设置的信息，此文件夹包含所有项目设置。项目设置菜单中设置的所有内容。它还包括编辑器版本号和构建设置，以及 Unity 系统使用的许多其他设置。编辑器版本号作为独立文件，直到 Unity 5 才添加。对于之前的任何版本，编辑器版本号都可以在项目设置文件中找到</p>
<h4 id="usersettings">UserSettings</h4>
<p>用来存储用户设置信息</p>
<h4 id="temp">Temp</h4>
<p>用来存储使用Unity编辑器打开项目时的临时数据，一旦关闭Unity编辑器也会被删除</p>
<h4 id="logs">Logs</h4>
<p>用来存储项目的日志信息（不包含编辑器日志信息）</p>
<h4 id="忽略导入的文件夹">忽略导入的文件夹</h4>
<pre><code>1. 隐藏的文件夹
2. 以 `.` 开头的文件和文件夹
3. 以 `~` 结尾的文件和文件夹
4. 扩展名为 `.cvs` 的文件和文件夹
5. 扩展名为 `.tmp` 的文件夹
</code></pre>
<h4 id="assets-目录结构设计仅-up-建议不作为标准">Assets 目录结构设计（仅 UP 建议，不作为标准）</h4>
<p><strong>一级目录设计原则：</strong></p>
<ul>
<li>目录尽可能少</li>
<li>区分编辑模式与运行模式</li>
<li>区分工程大版本</li>
<li>访问场景文件、全局配置文件便捷</li>
<li>不在一级目录做资源类别区分，只有 Video 类视频建议直接放到 StreamAssets 下</li>
</ul>
<p><strong>二级目录设计原则：</strong></p>
<ul>
<li>只区分资源类型</li>
<li>资源类型大类划分要齐全</li>
<li>不做子类型区分</li>
<li>不做功能区分</li>
<li>不做生命周期区分</li>
</ul>
<p><strong>三级目录设计原则：</strong></p>
<ul>
<li>Audio / Texture / Models 三级目录做子类型区分</li>
<li>其他类型资源可按功能模块 / 生命周期区分</li>
</ul>
<p><strong>四级目录设计原则：</strong></p>
<ul>
<li>只有 Audio / Texture / Models 做四级目录，可按功能模块 / 生命周期划分</li>
</ul>
<h4 id="要点">要点</h4>
<ol>
<li>不要在文件和文件夹名称中使用空格，因为我们 Unity 命令行工具无法自动处理带有空格的路径</li>
<li>不要在根目录中存储任何资产文件，尽可能使用子目录。</li>
<li>除非您真的需要，否则不要在根目录中创建任何额外的目录</li>
<li>与命名保持一致，如果决定将驼峰命名法用于目录名称，那么所有文件都应保持一致</li>
<li>使用单独的第三方文件夹来存储从资产商店导入的资产，他们通常有自己的结构，不应该改变</li>
<li>对于不完全确定的任何实验，请使用 SandBox 目录，当您与其他人一起处理项目时，请创建您的个人沙盒子目录，如：<em>SandBox / San</em></li>
</ol>
<h3 id="资源导入工作流">资源导入工作流</h3>
<h4 id="手动编写工具">手动编写工具</h4>
<p>优点：根据项目特点自定义安排导入工作流，并且可以和后续资源制作与大包工作流结合</p>
<p>缺点：存在开发和维护成本，会让编辑器菜单界面变得复杂，对新人理解工程不友好</p>
<p>适合类型：大型商业游戏团队</p>
<p><code>AssetPostprocessor</code>：</p>
<p>编写编辑器代码继承 AssetPostprocesser 对象自定义实现一些列 OnPreprocessXXX 接口修改资源导入设置属性</p>
<p><code>AssetsModifiedProcessor</code>（新试验接口）：</p>
<p>资源被添加、删除、修改、移动时回调该对象的 OnAssetsModified 接口</p>
<h4 id="利用-presets-功能">利用 Presets 功能</h4>
<p>优点：使用简单方便，只需要 Assets 目录结构合理规范即可</p>
<p>缺点：无法和后续工作流整合，只适合做资源导入设置。</p>
<p>适合类型：小型团队或中小规模项目</p>
<h4 id="利用-assetgraph-工具">利用 AssetGraph 工具</h4>
<p>优点：功能全，覆盖 Unity 资源工作流全流程，节点化编辑，直观</p>
<p>缺点：有一定上手成本，一些自定义生成节点也需要开发，不是 Unity 标准包，Unity 新功能支持较慢</p>
<p>适合类型：任何规模项目和中大型团队</p>
<p>AssetGraph 仓库地址：[https://github.com/Unity-Technologies/AssetGraph]</p>
<h2 id="create">Create</h2>
<h3 id="场景结构设计原则">场景结构设计原则</h3>
<ol>
<li>
<p>合理设计场景一级节点的同时，避免场景节点深度太深，一些代码生成的游戏对象如果不需要随父节点进行 Transform 的，一律放到根节点下</p>
</li>
<li>
<p>尽量使用 Prefab 物体构建场景，而不是直接创建的 GameObject 物体</p>
</li>
</ol>
<p>{% note info %}
用文本方式打开 Unity 场景会看到一系列引用信息，而如果创建一个 GameObject，则会记录详细相关参数，而如果引用的 Prefab，会直接引用加载好的 bundle 中的对象，这样构建引用速度会更快，更多参考下面的 <strong>Prefab</strong>
{% endnote%}</p>
<ol start="3">
<li>
<p>避免 <code>DontDestroyOnLoad</code> 节点下有太多生命周期过长或引用资源过多的复杂节点对象。Additve 模式添加的场景要尤为注意</p>
</li>
<li>
<p>最好为一些需要经常访问的节点添加 tag，静态节点一定要添加 Static 标记</p>
</li>
</ol>
<p>{% note primary%}
注意：复杂场景中，对于设置好 Tag 的节点，使用 <code>FindGameObjectWithTag</code> 方法取查找该节点更高效
{% endnote%}</p>
<h3 id="prefab">Prefab</h3>
<p>Unity 中的预制体是用来存储游戏对象、子对象及其所需组件的可重用资源，一般来说预制体资源可充当资源模版，在此模版基础上可以在场景中创建新的预制体实例</p>
<h4 id="优点">优点</h4>
<ul>
<li>由于预制体系统可以自动保持所有实例副本同步，因此可以比单纯地简单复制粘贴游戏对象做到更好的对象管理</li>
<li>此外通过预制体嵌套(Nested Prefabs)可以将一个预制体嵌套到另一个预制体中，从而创建多个易于编辑的复杂游戏对象层级视图</li>
<li>可以通过覆盖各个预制体实例的设置来创建预制体变体(Prefabs Variant)，从而可以将一系列覆盖组合在一起形成有意义预制体的变化</li>
</ul>
<h4 id="嵌套预制体与单预制体相比的优点与缺点">嵌套预制体与单预制体相比的优点与缺点</h4>
<ul>
<li>
<p>优点：</p>
<ul>
<li>嵌套预制体方便预制体管理，方便资源重复利用，易于统计场景复杂度</li>
<li>美术制作时可以比较合理的分配 UV、贴图利用率</li>
<li>方便关卡设计人员发挥，充分合理利用资源</li>
<li>嵌套预制体比较方便利用工具做 LOD，LOD 效果也比较好</li>
<li>嵌套预制体修改方便，只需修改子预制体就可以做到所有嵌套预制体同步</li>
<li>比较方便做场景遮挡剔除，可以做到精细的遮挡剔除优化效果</li>
</ul>
</li>
<li>
<p>缺点：</p>
<ul>
<li>手动做 Bundle 依赖时要按 Scene 方式处理，依赖关系较为复杂</li>
<li>可能会增加材质数量与 Drawcall 数量</li>
<li>不太适合做大规模远景对象</li>
<li>美术与关卡设计人员要充分考虑组合复杂度与特例场景显示，避免重复性和单一性，需要更多的沟通成本</li>
</ul>
</li>
</ul>
<h4 id="注意">注意</h4>
<ul>
<li>使用单独的预制件进行专业化，不要专业化实例</li>
</ul>
<p>如果您有两个敌人类型，并且它们仅因其属性而不同，请为属性制作单独的预制件，并将它们链接起来，这使得有可能在一个地方对每种类型进行更改或者无需更改场景即可进行更改</p>
<ul>
<li>将预制件链接到预制件</li>
</ul>
<p>不要将实例链接到实例：将预制件放入场景时，会保留预制件的链接；不会保留到实例的链接。尽可能链接到预制件可以减少场景设置，并减少更改场景的需要</p>
<ul>
<li>尽可能在实例之间自动建立链接</li>
</ul>
<p>如果您需要链接实例，请以编程方式建立链接。例如，玩家预制件可以在启动时向 GameManager 注册自己，或者 GameManager 可以在启动时找到 Player 预制件实例。</p>
<ul>
<li>如果您想添加其他脚本，请不要将网格放在预制件的根部</li>
</ul>
<p>当您从网格制作预制件时，首先将网格父到空游戏对象，并将其作为根。将脚本放在根上，而不是网格节点上。这样，用另一个网格替换网格就容易得多，而不会丢失您在检查器中设置的任何值</p>
<h4 id="使用-prefab-变体的一些限制">使用 Prefab 变体的一些限制</h4>
<ul>
<li>不能改变本体 Prefab 游戏对象 （GameObject）层级</li>
<li>不能删除本体 Prefab 中的游戏对象，但可以通过 Deactive 游戏对象来达到与删除游戏对象同样的效果</li>
<li>对于 Prefab 变体要保持其 Override 属性的变化，不能通过 Apply to base 把这些变化应用到本体 Prefab 上，这样会破坏基础 Prefab 的结构和功能</li>
</ul>
<h3 id="unity-ui">Unity UI</h3>
<p>UI 性能常见问题：</p>
<ul>
<li>
<p>GPU 片段着色器利用率过高（即填充率过度使用）</p>
</li>
<li>
<p>重建画布批次花费过多的 CPU 时间</p>
</li>
<li>
<p>画布批次的重建次数过多（过度 dirty）</p>
</li>
<li>
<p>生成顶点花费的 CPU 时间过高（通常来自文本）</p>
</li>
</ul>
<p>{% note info %}
Canvas 是一个原生代码 Unity 组件，由 Unity 的渲染系统使用，以提供将在游戏世界空间中绘制或顶部绘制的分层几何图形</p>
<p>Canvas 负责将其组成几何图形再组合成批处理，生成适当的渲染命令并将其发送到 Unity 的图形系统。所有这些都是在原生 C++ 代码中完成的，被称为重新批处理或批处理构建。当画布被标记为包含需要重新装包的几何图形时，画布被认为是 dirty
{% endnote %}</p>
<h4 id="canvas">Canvas</h4>
<p>Canvas 负责管理 UGUI 元素，负责 UI 渲染网格的生成与更新，并向 GPU 发送 DrawCall 指令</p>
<h4 id="re-batch-过程">Re-batch 过程</h4>
<ol>
<li>根据 UI 元素深度关系进行排序</li>
<li>检查 UI 元素的覆盖关系</li>
<li>检查 UI 元素材质并进行合批</li>
</ol>
<h4 id="ugui-渲染细节">UGUI 渲染细节</h4>
<ul>
<li>
<p>UGUI 中渲染是在 Transparent 半透明渲染队列中完成的，半透明队列的绘制顺序是从后往前画，由于 UI 元素做 Alpha Blend，我们在做 UI 时很难保障每一个像素不被重画，UI 的Overdraw 太高，这会造成片元着色器利用率过高，造成 GPU 负担</p>
</li>
<li>
<p>UI SpriteAtlas 图集利用率不高的情况下，大量完全透明的像素被采样也会导致像素被重绘，造成片元着色器利用率过高；同时纹理采样器浪费了大量采样在无效的像素上，导致需要采样的图集像素不能尽快的被采样，造成纹理采样器的填充率过低，同样也会带来性能问题</p>
</li>
</ul>
<h4 id="re-build-过程">Re-build 过程</h4>
<ul>
<li>
<p>在 <code>WillRenderCanvases</code> 事件调用 <code>PerformUpdate::CanvasUpdateRegistry</code> 接口</p>
<ul>
<li>通过 <code>ICanvasElement.Rebuild</code> 方法重新构建 Dirty Layout 组件</li>
<li>通过 <code>ClippingRegistry.Cullf</code> 方法，任何已注册的裁剪组件 Clipping Compnents (Such as Masks) 的对象进行裁剪剔除操作</li>
<li>任何 Dirty 的 Graphics Compnents 都会被要求重新生成图形元素</li>
</ul>
</li>
<li>
<p>Layout Rebuild</p>
<ul>
<li>UI 元素位置、大小、颜色发生变化</li>
<li>优先计算靠近 Root 节点，并根据层级深度排序</li>
</ul>
</li>
<li>
<p>Graphic Rebuild</p>
<ul>
<li>顶点数据被标记成 Dirty</li>
<li>材质或贴图数据被标记成 Dirty</li>
</ul>
</li>
</ul>
<p>图形和布局组件都依赖于 <code>CanvasUpdateRegistry</code> 类，该类未在 Unity Editor 的界面中公开。该类跟踪必须更新的布局组件和图形组件集，并在关联的 Canvas 调用 <code>willRenderCanvases</code> 事件时根据需要触发更新</p>
<h4 id="使用-canvas-的基本准则">使用 Canvas 的基本准则</h4>
<ul>
<li>将所有可能打断合批的层移到最下边的图层，尽量避免 UI 元素出现重叠区域</li>
<li>可以拆分使用多个同级或嵌套的 Canvas 来减少 Canvas 的 Rebatch 复杂度</li>
<li>拆分动态和静态对象放到不同 Canvas 下</li>
<li>不使用 Layout 组件</li>
<li>Canvas 的 RenderMode 尽量 Overlay 模式，减少 Camera 调用的开销</li>
</ul>
<h4 id="ugui-射线优化">UGUI 射线优化</h4>
<ul>
<li>必要的需要交互 UI 组件才开启 Raycast Target</li>
<li>开启 Raycast Targets 的 UI 组件越少，层级越浅，性能越好</li>
<li>对于复杂的控件，尽量在根节点开启 Raycast Target</li>
<li>对于嵌套的 Canvas，OverrideSorting 属性会打断射线，可以降低层级遍历的成本</li>
</ul>
<h4 id="ui字体">UI字体</h4>
<p>避免字体框重叠，造成合批打断</p>
<ul>
<li>
<p>字体网格重建</p>
<ul>
<li>UIText 组件发生变化时</li>
<li>父级对象发生变化时</li>
<li>UIText 组件或其父对象 enable/disable 时</li>
</ul>
</li>
<li>
<p>TrueTypeFontImporter</p>
<ul>
<li>支持 TTF 和 OTF 字体文件格式导入</li>
</ul>
</li>
<li>
<p>动态字体与字体图集</p>
<ul>
<li>运行时，根据 UIText 组件内容，动态生成字体图集，只会保存当前 Actived 状态的 UIText 控件中的字符</li>
<li>不同的字体库维护不同的 Texture 图集</li>
<li>字体 Size、大小写、粗体、斜体等各种风格都会保存在不同的字体图集中（有无必要，影响图集利用效率，一些利用不多的特殊字体可以采用图片代替或使用 Custom Font，Font Assets Creater 创建静态字体资源）</li>
<li>当前 Font Texture 不包含 UITex t需要显示的字体时，当前 Font Texture 需要重建</li>
<li>如果当前图集太小，系统也会尝试重建，并加入需要使用的字形，文字图集只增不减</li>
<li>利用 <code>Font.RequestCharacterInTexture </code>可以有效降低启动时间</li>
</ul>
</li>
<li>
<p>UI控件优化注意事项</p>
<ul>
<li>不需要交互的 UI 元素一定要关闭 Raycast Targe t选项</li>
<li>如果是较大的背景图的 UI 元素建议也要使用 Sprite 的九宫格拉伸处理，充分减小 UI Sprite 大小，提高 UI Atlas 图集利用率</li>
<li>对于不可见的 UI 元素，一定不要使用材质的透明度控制显隐，因为那样 UI 网格依然在绘制，也不要采用 active/deactive UI 控件进行显隐，因为那样会带来 gc 和重建开销</li>
<li>使用全屏的 UI 界面时，要注意隐藏其背后的所有内容，给 GPU 休息机会</li>
<li>在使用非全屏但模态对话框时，建议使用 <code>OnDemandRendering</code> 接口，对渲染进行降频</li>
<li>优化裁剪 UI Shader，根据实际使用需求移除多余特性关键字</li>
</ul>
</li>
</ul>
<h4 id="滚动视图-scroll-view-优化">滚动视图 Scroll View 优化</h4>
<ul>
<li>使用 RectMask2d 组件裁剪</li>
<li>使用基于位置的对象池作为实例化缓存</li>
</ul>
<h3 id="unity-中的物理解决方案">Unity 中的物理解决方案</h3>
<h4 id="面向对象的项目内置物理引擎">面向对象的项目内置物理引擎</h4>
<ul>
<li>2D 物理系统</li>
</ul>
<p>Box2D</p>
<p>Erin Catto 用 C++ 编写的免费开源二维物理模拟器引擎</p>
<ul>
<li>3D 物理系统</li>
</ul>
<p>NVIDIA PhysX</p>
<p>是一个可扩展的多平台物理解决方案，支持各种设备，从智能手机到高端多核 CPU 和 GPU</p>
<h4 id="面向数据的项目物理引擎包">面向数据的项目物理引擎包</h4>
<ul>
<li>Unity Physics</li>
</ul>
<p><a href="https://docs.unity3d.com/Packages/com.unity.physics@latest">Unity Physics</a> 软件包是 Unity 面向数据技术堆栈（DOTS）的一部分，提供了一个确定性刚体动力学系统和空间查询系统</p>
<ul>
<li>Havok Physics for Unity</li>
</ul>
<p><a href="https://docs.unity3d.com/Packages/com.havok.physics@1.0/manual/index.html">Havok Physics</a> 提供了最快、最强大的碰撞检测和物理模拟技术，这就是为什么它已成为游戏行业的黄金标准，并被这一代游戏机一半以上的畅销游戏所使用</p>
<p>这个软件包将 Havok Physics 的力量带到了 Unity 的 DOTS 框架中。它建立在 Unity Physics 之上，Unity 和 Havok 为 DOTS 编写的 C# 物理引擎</p>
<h4 id="collider-组件部分优化">Collider 组件部分优化</h4>
<ul>
<li>
<p>Trigger 与 Collider</p>
<ul>
<li>Trigger 对象的碰撞会被物理引擎所忽略，通过 <code>OnTriggerEnter/Stay/Exit</code> 函数回调</li>
<li>Collider 对象由物理引擎触发碰撞，通过 <code>OnCollisionEnter/Stay/Exit</code> 函数回调</li>
<li>Trigger 对象不需要 RigidBody 组件，Collider 对象必须至少有一个 Collider 对象有RigidBody 组件</li>
<li>Trigger 对象更高效</li>
</ul>
</li>
<li>
<p>尽量少使用 MeshCollider，可以用简单 Collider 代替，即使用多个简单 Collider 组合代替也要比复杂的 MeshCollider 来的高效</p>
<ul>
<li>MeshCollider 是基于三角形面的碰撞</li>
<li>MeshCollider 生成的碰撞体网格占用内存也较高</li>
<li>MeshCollider 即使要用也要尽量保障其是静态物体</li>
<li>可以通过 PlayerSetting 选项中勾选 Prebake Collision Meshes 选项来在构建应用时预先 Bake 出碰撞网格</li>
</ul>
</li>
</ul>
<h4 id="rigidbody-组件部分优化">RigidBody 组件部分优化</h4>
<ul>
<li>Kinematic 与 RigidBody
<ul>
<li>Kinematic 对象不受物理引擎中力的影响，但可以对其他 RigidBody 施加物理影响</li>
<li>RigidBody 完全由物理引擎模拟来控制，场景中 RigidBody 数量越多，物理计算负载越高</li>
<li>勾选了 Kinematic 选项的 RigidBody 对象会被认为是 Kinematic 的，不会增加场景中的 RigidBody 个数</li>
<li>场景中的 RigidBody 对象越少越好</li>
</ul>
</li>
</ul>
<h4 id="raycast-与-overlap-部分的优化">RayCast 与 Overlap 部分的优化</h4>
<ul>
<li>Unity 物理中 RayCast 与 Overlap 都有 NoAlloc 版本的函数，在代码中调用时尽量用 NoAlloc 版本，这样可以避免不必要的 GC 开销</li>
<li>尽量调用 RayCast 与 Overlap 时要指定对象图层进行对象过滤，并且 RayCast 要还可以指定距离来减少一些太远的对象查询</li>
<li>此外如果是大量的 RayCast 操作还可以通过 RaycastCommand 的方式批量处理，充分利用 JobSystem 来分摊到多核多线程计算</li>
</ul>
<p>{%note info%}
<a href="https://docs.unity3d.com/Manual/JobSystem.html">Job System</a> 允许您编写简单安全的多线程代码，以便您的应用程序可以使用所有可用的 CPU 内核来执行代码。这可以帮助提高应用程序的性能
{% endnote%}</p>
<h3 id="动画">动画</h3>
<h4 id="animation-的一些细节">Animation 的一些细节</h4>
<ul>
<li>播放单个 AnimationClip 速度，Legacy Animation 系统更快，因为老系统是直接采样曲线并直接写入对象 Transform</li>
</ul>
<p>Unity 的当前动画系统具有用于混合的临时缓冲区，并会对采样曲线和其他数据进行额外复制。当前系统布局已针对动画混合和更复杂设置进行优化</p>
<ul>
<li>针对动画的缩放曲线比位移、旋转曲线开销更大</li>
</ul>
<p>{%note warning%}
注意：这不适用于常量曲线（具有相同<a href="https://docs.unity3d.com/cn/current/Manual/AnimationClips.html">动画剪辑</a>长度值的曲线）。常量曲线经过优化，成本低于比普通曲线。常量曲线的值与默认场景值相同时，常量曲线不会每帧都写入场景
{% endnote %}</p>
<ul>
<li>大多数时间，Unity 都在估算动画，并将动画层和动画状态机的开销保持在最低水平。向 Animator 添加另一层（无论同步与否）的成本取决于层播放的动画和混合树。层的权重为零时，Unity 会跳过层更新</li>
</ul>
<h4 id="animator-的一些细节">Animator 的一些细节</h4>
<ul>
<li>不要使用字符串来查询 Animator，而使用哈希来查询 Animator</li>
<li>使用曲线标记来处理动画事件</li>
<li>使用 Target Marching 函数来协助处理动画</li>
<li>将 Animator 的 CullingMode 设置成 Based On Renderers 来优化动画，并禁用 SkinMesh Renderer 的 Update When Offscreen 属性来让角色不可见时动画不更新</li>
</ul>
<h4 id="playable-api">Playable API</h4>
<p><a href="https://docs.unity3d.com/cn/current/Manual/Playables.html">Playables API</a> 提供一种通过组织和评估树状结构（称为 PlayableGraph）中的数据源来创建工具、效果或其他游戏机制的方法。PlayableGraph 允许您混合、融合和修改多个数据源，并通过单个输出播放它们。</p>
<p>Playables API 支持动画、音频和脚本。Playables API 还提供通过脚本与动画系统（Mecanim）和音频系统进行交互的能力。</p>
<p>尽管 Playables API 目前仅限于动画、音频和脚本，但它是一种通用 API，最终可供视频和其他系统使用</p>
<p>Playable API 优点：</p>
<ul>
<li>支持动态动画混合，可为场景中的对象提供自己的动画，并可以动态添加到 PlayableGraph 当中使用</li>
<li>允许创建播放单个动画，而并不会产生创建和管理 AnimatorController 资源所涉及的开销，可更加灵活的控制 PlayableGraph 的数据流，可以插入自定义的 AimationJob</li>
<li>可以控制动画文件加载策略，按需加载、异步加载等</li>
<li>允许用户动态创建混合图，并直接逐帧控制混合权重（甚至可以混合 AniationClip 与 AnimatorController 动画）</li>
<li>可以运行时动态创建，根据条件添加可播放节点。而不需要提前提供一套 PlayableGraph 运行时启动和禁用节点，可以做到自由度更高的 override 机制</li>
<li>可加载自定义配置数据，更加方便的和其他游戏系统整合</li>
</ul>
<p>Playable API 缺点：</p>
<ul>
<li>没有直接使用 Animator Graph 直观</li>
<li>混合模式没有现成的，需要自己实现</li>
<li>需要开发更多的配套工具</li>
<li>有一定学习成本</li>
</ul>
<h4 id="解决方案选择">解决方案选择</h4>
<ul>
<li>一些简单、少量曲线动画可以使用 Animation 或动画区间库如 Dotween/iTween 等完成，如UI 动画，Transform 动画等。</li>
<li>角色骨骼蒙皮动画如果骨骼较少，Animation Clip 资源不多，对动画混合表现要求不高的项目可以采用 Legacy Animation。注意控制总体曲线数量</li>
<li>一些角色动画要求与逻辑有较高的交互、并且动画资源不多的项目可以直接用 Animator Graph 完成</li>
<li>一些动作游戏，对动画混合要求较高、有一些高级动画效果要求、动画资源量庞大的项目，建议采用 Animator+Playable API 扩展 Timeline 的方式完成</li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li>
<p><a href="http://www.arreverie.com/blogs/unity3d-best-practices-folder-structure-source-control/">Unity3D Best Practices: Folder structure &amp; Source Control</a></p>
</li>
<li>
<p><a href="https://medium.com/@jsj5909/a-brief-anatomy-of-a-unity-project-folder-563bd3f4ad40">A Brief Anatomy of A Unity Project Folder</a></p>
</li>
<li>
<p><a href="https://docs.unity3d.com/cn/2021.2/Manual/DefaultPresetsByFolder.html">Applying default presets to Assets by folder</a></p>
</li>
<li>
<p><a href="https://learn.unity.com/tutorial/optimizing-unity-ui#">Optimazing Unity UI</a></p>
</li>
<li>
<p><a href="https://docs.unity3d.com/cn/current/Manual/MecanimPeformanceandOptimization.html">Animation performance and optimization</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Unity 性能优化 Chapter1</title>
      <link>https://brealinhub.com/posts/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-chapter1/</link>
      <pubDate>Fri, 17 Mar 2023 16:52:16 +0000</pubDate>
      
      <guid>https://brealinhub.com/posts/unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-chapter1/</guid>
      <description>前言 观看 bilibili @Metaverse大衍神君 视频记录笔记，是本来作者留下的笔记经整理也有自己不太懂的地方扩展延伸，如有错误还请海涵指正！
环境搭建 使用如下命令拉起测试项目并使用 Unity 打开
git clone https://github.com/lwwhb/Unity2022_SUNTAIL_Stylized_Fantasy_Village_Optimization 个人使用的 2022.1.16 版本打开，会出现一个 com.unity.render-pipelines.universal 的包错误，个人解决方案是在 PackageManage 里删除这个包后，Unity 会自动提示升级材质，点击后会自动安装新版的 URP 包，也会自动配置好渲染管线
{% note warning%} 注意这里我将项目设置为了 URP（SRP） 渲染管线会导致下面无法查看场景 Mipmap 选项，在视频教程中的内置渲染管线（built-in）可以查看 {% endnote %}
打开项目的 Autoconnect Profiler 并在场景加入 DebugCanvas 方便移动设备的调试
关闭移动平台的 VSync Count 选项，以发挥最大性能
{% note primary %}
VSync Count：每帧之间应传递的垂直同步数量 Unity 通过将平台的默认目标帧速率除以 VSyncCount 的值来计算目标帧速率
{% endnote %}
未优化时的性能指标 生成的 Android APK大小 550M 三角形平均面熟 150-200 万，峰值 230 万 渲染批次 1500-1800 次 SetPassCall 200 次以上 小米11 ultra平均 FPS :10 FPS，iPhone XS Max 15FPS 内存 小米 11 ultra 1.</description>
      <content:encoded><![CDATA[<h1 id="前言">前言</h1>
<p>观看 bilibili <a href="https://www.bilibili.com/video/BV1AL4y1b75c/?spm_id_from=333.788&amp;vd_source=3413f403c4f649d0c89b6453b13d050f"><strong>@Metaverse大衍神君</strong></a> 视频记录笔记，是本来作者留下的笔记经整理也有自己不太懂的地方扩展延伸，如有错误还请海涵指正！</p>
<h1 id="环境搭建">环境搭建</h1>
<p>使用如下命令拉起测试项目并使用 Unity 打开</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-zsh" data-lang="zsh"><span class="line"><span class="cl">git clone https://github.com/lwwhb/Unity2022_SUNTAIL_Stylized_Fantasy_Village_Optimization
</span></span></code></pre></div><p>个人使用的 2022.1.16 版本打开，会出现一个 <em><code>com.unity.render-pipelines.universal</code></em> 的包错误，个人解决方案是在 PackageManage 里删除这个包后，Unity 会自动提示升级材质，点击后会自动安装新版的 URP 包，也会自动配置好渲染管线</p>
<p>{% note warning%}
注意这里我将项目设置为了 URP（SRP） 渲染管线会导致下面无法查看场景 <strong>Mipmap</strong> 选项，在视频教程中的内置渲染管线（built-in）可以查看
{% endnote %}</p>
<p>打开项目的 Autoconnect Profiler 并在场景加入 DebugCanvas 方便移动设备的调试</p>
<p>关闭移动平台的 <a href="https://docs.unity3d.com/ScriptReference/QualitySettings-vSyncCount.html">VSync Count</a> 选项，以发挥最大性能</p>
<p>{% note primary %}</p>
<p>VSync Count：每帧之间应传递的垂直同步数量
Unity 通过将平台的默认目标帧速率除以 VSyncCount 的值来计算目标帧速率</p>
<p>{% endnote %}</p>
<h2 id="未优化时的性能指标">未优化时的性能指标</h2>
<ul>
<li>生成的 Android APK大小 550M</li>
<li>三角形平均面熟 150-200 万，峰值 230 万</li>
<li>渲染批次 1500-1800 次</li>
<li>SetPassCall 200 次以上</li>
<li>小米11 ultra平均 FPS :10 FPS，iPhone XS Max 15FPS</li>
<li>内存 小米 11 ultra 1.5 GB， iPhone XS Max 1 GB</li>
<li>纹理资源小米 11 ultra 670M， iPhone XS Max 530M</li>
<li>Mesh资源小米 11 ultra 423M，iPhone XS Max 423M</li>
<li>音效资源小米 11 ultra 76M，iPhone XS Max 76M</li>
</ul>
<h1 id="静态优化">静态优化</h1>
<p>导入 - 创建 - 运行 - 分发 - 加载</p>
<figure>
    <img loading="lazy" src="/img/Unity%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96/AssetWorkflowOverview.svg"/> 
</figure>

<h2 id="import">Import</h2>
<p>内部导入如：prefab、animation、timeline、rendertexture 等
外部导入如：模型网格 Mesh、纹理、音乐音效、字体、动画视频等</p>
<p>合理的资源导入设置、规格在不同平台下表现不同</p>
<p>在此使用 <a href="https://upr.unity.cn">Unity UPR</a> 性能测试解决方案，查看我们导入的资源存在哪些问题，正常注册、创建项目、下载 <a href="https://upr.unity.cn/instructions/assetchecker"><strong>Asset Checker</strong></a></p>
<p>以个人 Mac 为例：</p>
<p><code>cd</code> 到刚下载的路径下终端输入：<code>./assetcheck --h</code> 可以查看到相关帮助信息</p>
<p>之后配置联系到项目：<code>./assetcheck --project=&lt;项目路径&gt; --projectId=&lt;项目ID&gt;</code></p>
<p>{% note info %}</p>
<p>项目 ID：在创建的 UPR 项目下点击，可以查看到相关项目包名和 Project ID（项目 ID）</p>
<p>{% endnote %}</p>
<p>这样稍等一会，我们就可以在 UPR 项目中查看到我们的项目报告以便分析</p>
<p><strong>下面分析项目报告</strong></p>
<h3 id="audio">Audio</h3>
<ul>
<li><strong>启用 Force to Mono</strong></li>
</ul>
<p>将双声道相同的音频在不丢失内容的情况下，可强制改为单声道以节约内存</p>
<p>{% note primary %}</p>
<p><a href="https://medium.com/@made-indrayana/understanding-audio-compression-settings-in-unity-e879a821023f"><strong>Compression Format</strong></a></p>
<p><strong>PCM：</strong>
它是一种无损、未压缩的编解码器和格式，在Unity中播放也几乎不需要CPU处理，因为它不需要解压缩，所以在构建项目的时候大小大幅增加，这特别是对移动开发不太友好，</p>
<p><em>一个附带说明是，Unity 似乎正在对一些音频文件进行自己的无损压缩，在选择 PCM 格式下，音频还是会有不同程度的压缩（大概 65% - 100%，但几乎没有影响到质量）</em></p>
<p><strong>ADPCM:</strong>
ADPCM 的算法在 Unity 中提供了固定的压缩比，这导致文件比原始 PCM 音频小约3.5倍</p>
<p>优势：与 PCM 一样，解压缩或解码此编解码器的成本非常轻，与 PCM 相比只是多一点，以换取大幅减小的文件大小
劣势：缺点是压缩方法本身，ADPCM 压缩音频数据的方式偶尔会导致原始文件中没有的失真或“额外噪音”</p>
<p><strong>Vorbis：</strong>
Vorbis是一种完全开放的、非专有的、免专利和免版税的通用音频格式。这是一个非常高效的音频编解码器，提供高质量的有损压缩，在 Unity 中还有一个质量滑块，这使我们能够决定要降低多少音频质量</p>
<p><strong>MP3：</strong>
用于有损压缩的高效音频编解码器，与 Vorbis 相似。它可以将音频压缩到非常小的尺寸，而不会造成太大的质量损失，但有一个主要区别：MP3 不能无缝循环。如果想让游戏中的声音循环，如音乐或氛围，最好不要选择此压缩格式</p>
<p><em>在  IOS 平台上可能会对 MP3 格式有特殊优化，一般来说，建议尽可能选择 Vorbis 而不是MP3，因为 Vorbis 以相同的比特率提供更高效的编码，这意味着将以相同的文件大小获得更高的质量</em>{% endnote %}</p>
<ul>
<li><strong>优化采样率</strong></li>
</ul>
<p>Sample Rate Settings：定义了单位时间内从连续信号中提取并组成离散信号的采样个数</p>
<ul>
<li><strong>加载类型</strong></li>
</ul>
<p>Decompress On Load：</p>
<p>会将音频数据解压缩并解码到内存的原始大小，使其能够以最少的 CPU 使用率按需播放。这样做的权衡是，音频数据将占用内存中的最大空间，这就是为什么它只适用于经常播放并需要在很短的时间内准备好的小型音频文件，如脚步声、UI 声音、枪声和其他武器声音等</p>
<p>Compressed In Memory：</p>
<p>会将音频数据以压缩状态存储在内存中，但在播放时需要 CPU 进行解压缩和解码。这样做的优点是，存储介质没有读取时间和内存使用量小，每次播放时使用多一点 CPU 来解压和解码。对于不经常播放的声音，如对象交互声音、随机氛围声音和其他许多声音，建议使用此设置</p>
<p>Streaming：</p>
<p>当音频数据实时从存储介质中读取时，会进行解码和解压缩。这具有最低的内存使用率，但最高的 CPU 使用率。这将相当慢，因为 CPU 必须首先从存储介质中读取，这比内存慢。因此，此选项仅建议在每个场景的一个或两个音频文件上使用。大多数情况下，此设置将用于音乐或氛围文件，因为这些资产很大，不希望它们占用可用于其他东西的宝贵内存资源</p>
<p>{% note info %}</p>
<p><strong>为什么 PCM 总是最终格式？</strong>
通常播放编码文件（无论是音频还是视频）的应用程序需要将该文件解码为目标设备可以在标准端口上输出的格式，大多数音频设备都在等待 PCM 数据。解码器很可能会集成到软件中，或者在极少数情况下，您将有实际的硬件或芯片接管解码过程来缓解 CPU</p>
<p>{% endnote %}</p>
<figure>
    <img loading="lazy" src="/img/Unity%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96/UnityAudioPipeline.png"/> 
</figure>

<ul>
<li><strong>删除 Audio Source</strong></li>
</ul>
<p>对于用不到的音视频文件，应采用删除释放内存而不是简单的将音量设置为 0</p>
<h3 id="fbx">FBX</h3>
<p><strong>DCC 中模型导出</strong></p>
<ul>
<li>
<p>Unity 支持多种标准和专有模型文件格式（DCC）Unity 内部使用 .fbx 文件格式作为其导入链。最佳做法尽可能使用 .fbx 文件格式，并且不应在生产中使用专有文件格式</p>
</li>
<li>
<p>优化原始导入模型文件，删除不需要的数据</p>
<ul>
<li>统一单位</li>
<li>导出的网格必须是多边形拓扑网格，不能是贝塞尔曲线、样条曲线、NURBS、NURMS、细分曲面等</li>
<li>烘培 Deformers, 在导出之前，确保变形体被烘培到网格模型上，如骨骼形变烘培到蒙皮权重上</li>
<li>不建议模型使用到的纹理随模型导出</li>
<li>如果你需要导入 blend shape normals，必须要指定光滑组 smooth groups</li>
<li>DCC 导出面板设置, 不建议携带场景信息导出，如不建议导出摄像机、灯光、材质等信息，因为这些的信息与 Unity 内默认都不同。除非你自己为某 DCC 做过自定义导出插件</li>
</ul>
</li>
</ul>
<p><strong>原始模型文件对性能的影响点</strong></p>
<ul>
<li>最小化面数，不要使用微三角形，分布尽量均匀</li>
<li>合理的网络拓扑和平滑组</li>
<li>尽量少的使用材质个数</li>
<li>尽可能少的使用蒙皮网格</li>
<li>尽可能少的骨骼数量</li>
<li>FK 与 IK 节点没分离，IK 节点没删除</li>
</ul>
<p><strong>模型优化</strong></p>
<ul>
<li>尽可能的将网格合并到一起</li>
<li>尽可能使用共享材质</li>
<li>不要使用网格碰撞体</li>
<li>不必要不要开启网格读写</li>
<li>使用合理的 LOD 级别</li>
<li>Skin Weights 受骨骼影响个过多</li>
<li>合理压缩网格</li>
<li>不需要 rigs 和 BlendShapes 尽量关闭</li>
<li>如果可能，禁用法线或切线</li>
<li>多套模型</li>
</ul>
<p><strong>资源检查报告</strong></p>
<ul>
<li>
<p>其中两项建议与模型动画有关，而测试项目中所有模型资源都不涉及动画，可以将 Rig 标签下的 Animation Type 设置为 None，并关闭 Animation 标签下的 Import Animations 选项，设置 Materials 标签中的 Material Creation Mode为 None</p>
</li>
<li>
<p>开启 Project Settings —&gt; Player —&gt;Optimization下的 Vertex Compression （定点通道压缩，会降低精度）与 Optimize Mesh Data （删除未使用的网格组建）选项</p>
</li>
</ul>
<h3 id="纹理">纹理</h3>
<p><a href="https://docs.unity3d.com/Manual/TextureTypes.html#texture-types"><strong>Texture types：</strong></a></p>
<ul>
<li>
<p>Default</p>
<p>用于所有纹理的最常见纹理类型，它提供对纹理导入的大多数属性的访问</p>
</li>
<li>
<p>Normal map</p>
<p>将颜色通道转换为适合实时正常映射的格式</p>
</li>
<li>
<p>Editor GUI and Legacy GUI</p>
<p>在任何 HUD 或 GUI 控件上使用纹理，对于此纹理类型，纹理形状属性始终设置为2D</p>
</li>
<li>
<p>Cursor</p>
<p>使用纹理作为自定义光标，此纹理类型的纹理形状属性始终设置为 2D</p>
</li>
<li>
<p>Sprite (2D and UI)</p>
<p>通常作用于 2D 游戏和 UI 中，对于此纹理类型纹理形状属性始终设置为 2D</p>
</li>
<li>
<p>Cookie</p>
<p>使用内置渲染管道中用于 cookie 的基本参数设置纹理，使用此纹理类型，Unity 根据选定的光类型自动更新纹理形状属性</p>
<ul>
<li>定向和聚光光源的 cookies 总是 2D 纹理</li>
<li>点光源 cookies 必须是 cubemaps（立方体类型）</li>
</ul>
<p>{% note info %}
cubemaps：六个正方形纹理的集合，可以表示环境中的反射或几何图形后面绘制的天空框。六个正方形构成了围绕物体的虚构立方体的面；每个面代表沿着世界轴方向（向上、向下、向左、向右、向前和向后）的视图
{% endnote %}</p>
</li>
<li>
<p>Lightmap</p>
<p>此选项允许编码为特定格式（RGBM 或 dLDR，取决于平台）和后处理，纹理数据的步骤（推拉膨胀通道）。对于此纹理类型，纹理形状属性始终设置为 2D。</p>
</li>
<li>
<p>Single Channel</p>
<p>如果在纹理中只需要一个通道，使用此纹理类型，还可以更改纹理形状属性以定义纹理形状</p>
</li>
</ul>
<p><strong>Texture Shape：</strong></p>
<ul>
<li>2D 最常用的 2D 纹理，默认选项</li>
<li>Cube 一般用于天空和与反射探针，默认支持 Default、Normal、Single Channel 几种类型纹理，可以通过 Assets &gt; Create &gt; Legacy &gt; Cubemap 生成，也可以通过 C# 代码  <code>Camera.RenderToCubemap</code> 在脚本中生成</li>
<li>2D Array 纹理数组，可以极大提高大量相同大小和格式的纹理访问效率，但需要特定平台支持，可以通过引擎 SystemInfo.supports2DArrayTextures 接口运行时查看是否支持</li>
<li>3D 通过纹理位图方式存储或传递一些3D结构化数据，一般用于体积仿真，如雾效、噪声、体积数据、距离场、动画数据等信息，可以外部导入，也可运行时程序化创建</li>
</ul>
<p><strong>Alpha Source：</strong></p>
<p>默认选择 Input Texture Alpha 就好，如果确定不使用原图中的 Alpha 通道，可以选择 None，另外 From Gray Scale 我们一般不会选用</p>
<p><strong>Alpha Is Transparency：</strong></p>
<p>指定 Alpha 通道是否开启半透明，如果位图像素不关心是否要半透明可以不开启此选项。这样 Alpha 信息只需要占 1bit 以节省内存</p>
<p><strong>Ignore Png file gamma：</strong></p>
<p>是否忽略 png 文件中的 gamma 属性，这个选项是否忽略取决于 png 文件中设置不同 gamma 属性导致的显示不正常，一般原图制作流程没有特殊设置，这个选项一般默认就好</p>
<p><strong>Read / Write</strong></p>
<p>开启此选项会导致内存量增加一倍，默认我们都是不开启，除非你的脚本逻辑中需要动态读写该纹理时需要打开此选项</p>
<hr>
<p>纹理的大小都是 2 的幂次方，如果纹理不符合则是自动化为最近的 2 的幂次方大小，这可能会造成纹理浪费，不符合 Unity 压缩格式，纹理大小也直接影响内存和显存大小</p>
<p>选择合适纹理大小应尽量遵循以下经验：</p>
<ul>
<li>
<p>不同平台、不同硬件配置选择不同的纹理大小，Unity下可以采用 bundle 变体设置多套资源、通过 Mipmap 限制不同平台加载不同 level 层级的贴图</p>
</li>
<li>
<p>根据纹理用途的不同选择不同的纹理加载方式，如流式纹理加载 Texture Streaming、稀疏纹理 Sparse Texture、虚拟纹理 VirtualTexture 等方式</p>
</li>
<li>
<p>不能让美术人员通过增加纹理大小的方式增加细节，可以选择细节贴图 DetailMap 或增加高反差保留的方式</p>
</li>
<li>
<p>在不降低视觉效果的情况下尽量减小贴图大小，最好的方式是纹理映射的每一个纹素的大小正好符合屏幕上显示像素的大小，如果纹理小了会造成欠采样，纹理显示模糊，如果纹理大了会造成过采样，纹理显示噪点。这一点做到完美平衡很难保障，可以充分利用 Unity 编辑器下 SceneView -&gt; DrawMode -&gt; Mipmap 来查看在游戏摄像机视角下哪些纹理过采样，哪些纹理欠采样，进而来调整纹理大小</p>
</li>
</ul>
<p><strong>纹理颜色空间：</strong></p>
<p>默认大多数图像处理工具都会使用 sRGB 颜色空间处理和导出纹理。但如果你的纹理不是用作颜色信息的话，那就不要使用 sRGB 空间，如金属度贴图、粗糙度贴图、高度图或者法线贴图等。一旦这些纹理使用 sRGB 空间会造成视觉表现错误</p>
<p>{% note primary%}
<a href="https://www.techarthub.com/an-introduction-to-texture-compression-in-unity/"><strong>什么是颜色（位）的深度？</strong></a>
图像的颜色（位）深度描述了使用多少位数据来存储每个像素的颜色值。图像的位深度越大，可以使用的颜色就越多（但不一定存在）这些位通常分布在多个通道上，以产生最终的颜色</p>
<p>{% endnote %}</p>
<table>
<thead>
<tr>
<th style="text-align:center">Depth</th>
<th style="text-align:center">Distribution</th>
<th style="text-align:center">Colors</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">8-bit (RGB)</td>
<td style="text-align:center">R3 G3 B2</td>
<td style="text-align:center">2<sup>8 * 8 * 8</sup></td>
</tr>
<tr>
<td style="text-align:center">16-bit (RGBA)</td>
<td style="text-align:center">R3 G3 B2 A8</td>
<td style="text-align:center">2<sup>8 * 8 * 8</sup> + alpha</td>
</tr>
<tr>
<td style="text-align:center">16-bit (RGB)</td>
<td style="text-align:center">R5 G6 B5</td>
<td style="text-align:center">2<sup>16 * 16 * 16</sup></td>
</tr>
<tr>
<td style="text-align:center">24-bit (RGBA)</td>
<td style="text-align:center">R5 G6 B5 A8</td>
<td style="text-align:center">2<sup>16 * 16 * 16</sup> + alpha</td>
</tr>
<tr>
<td style="text-align:center">24-bit (RGB)</td>
<td style="text-align:center">R8 G8 B8</td>
<td style="text-align:center">2<sup>24 * 24 * 24</sup></td>
</tr>
<tr>
<td style="text-align:center">32-bit (RGB)</td>
<td style="text-align:center">R8 G8 B8 A8</td>
<td style="text-align:center">2<sup>32 * 32 * 32</sup></td>
</tr>
</tbody>
</table>
<p><strong>纹理压缩：</strong></p>
<p><a href="https://docs.unity3d.com/Manual/class-TextureImporterOverride.html">https://docs.unity3d.com/Manual/class-TextureImporterOverride.html</a></p>
<p>纹理压缩是指图像压缩算法，保持贴图视觉质量的同时，尽量减小纹理数据的大小。默认情况下我们的纹理原始格式采用 PNG 或 TGA 这类通用文件格式，但与专用图像格式相比他们访问和采样速度都比较慢，无法通用 GPU 硬件加速，同时纹理数据量大，占用内存较高。所以在渲染中我们会采用一些硬件支持的纹理压缩格式，如 ASTC 、ETC、ETC2、DXT 等</p>
<p><strong>纹理图集：</strong></p>
<p>纹理图集是一系列小纹理图像的集合</p>
<ul>
<li>
<p>优点：</p>
<p>一是采用共同纹理图集的多个静态网格资源可以进行静态合批处理，减少DrawCall 调用次数</p>
<p>二是纹理图集可以减少碎纹理过多，因为他们打包在一个图集里，通过压缩可以更有效的利用压缩，降低纹理的内存成本和冗余数据</p>
</li>
<li>
<p>缺点</p>
<p>美术需要合理规划模型，并且要求模型有相同的材质着色器，或需要制作通道图去区分不同材质，制作和修改成本较高</p>
</li>
</ul>
<p><strong>纹理过滤：</strong></p>
<ul>
<li>
<p>Nearest Point Filtering：临近点采样过滤最简单、计算量最小的纹理过滤形式，但在近距离观察时，纹理会呈现块状</p>
</li>
<li>
<p>Bilinear Filtering：双线性采样过滤会对临近纹素采样并插值化处理，对纹理像素进行着色。双线性过滤会让像素看上去平滑渐变，但近距离观察时，纹理会变得模糊</p>
</li>
<li>
<p>Trilinear Filtering：三线性过滤除与双线性过滤相同部分外，还增加了Mipmap等级之间的采样差值混合，用来平滑过度消除Mipmap之间的明显变化</p>
</li>
<li>
<p>Anisotropic Filtering：各向异性过滤可以改善纹理在倾斜角度下的视觉效果，跟适合用于地表纹理</p>
</li>
</ul>
<p><strong>纹理 Mipmap：</strong></p>
<p>逐级减低分辨率来保存纹理副本。相当于生成了纹理 LOD，渲染纹理时，将根据像素在屏幕中占据的纹理空间大小选择合适的 Mipmap 级别进行采样</p>
<p>{% note info %}
<strong>Generate Mip Maps</strong></p>
<p>什么时候不需要生成 MipMaps?</p>
<ol>
<li>2D场景</li>
<li>固定视角，摄像机无法缩放远近</li>
</ol>
<ul>
<li>
<p>Border Mip Maps 默认不开启，只有当纹理的是 Light Cookies 类型时，开启此选项来避免 colors bleeding 现象导致颜色渗透到较低级别的 Mip Level 纹理边缘上</p>
</li>
<li>
<p>MipMap Filtering</p>
<ul>
<li>Box 最简单，随尺寸减小，Mipmap 纹理变得平滑模糊</li>
<li>Kaiser，避免平滑模糊的锐化过滤算法</li>
</ul>
</li>
<li>
<p>Mip Maps Preserve Coverage，只有需要纹理在开启 mipmap 后也需要做 Alpha Coverage 时开启。默认不开启</p>
</li>
<li>
<p>Fadeout MipMaps 纹理 Mipmap 随 Mip 层级淡化为灰色，一般不开启，只有在雾效较大时开启不影响视觉效果</p>
</li>
</ul>
<p>{% endnote %}</p>
<p>{% note primary%}
选择合适纹理过滤的最佳经验</p>
<ul>
<li>
<p>使用双线性过滤平衡性能和视觉质量</p>
</li>
<li>
<p>有选择地使用三线性过滤，因为与双线性过滤相比，它需要更多的内存带宽</p>
</li>
<li>
<p>使用双线性和 2x 各向异性过滤，而不是三线性和 1x 各向异性过滤，因为这样做不仅视觉效果更好，而且性能也更高</p>
</li>
<li>
<p>保持较低的各向异性级别。仅对关键游戏资源使用高于 2 的级别
{% endnote %}</p>
</li>
<li>
<p>优点：</p>
<p>GPU 不需要在远距离上对对象进行全分辨率纹理采样，因此可以提高纹理采样性能</p>
<p>同时也解决了远距离下的过采样导致的噪点问题，提高的纹理渲染质量</p>
</li>
<li>
<p>缺点：</p>
<p>由于 Mipmap 纹理要生成低分辨率副本，会造成额外的内存开销（可使用 <strong>MipmapStreaming</strong> 来优化）</p>
</li>
</ul>
<p><strong>其他可能有问题的纹理类型：</strong></p>
<ul>
<li>纹理图集大小设置不合理，图集利用率低</li>
<li>大量只有颜色差异的图片</li>
<li>UI 背景贴图而不采用 9 宫格缩放的图</li>
<li>纯色图没有使用 Single Channel</li>
<li>不合理的半透明 UI，占据大量屏幕区域，造成 Overdraw 开销</li>
<li>大量 2D 序列帧动画，而且图片大，还不打图集</li>
<li>不合理的通道图利用方案</li>
<li>大量渐变色贴图，没有采用 1 像素过渡图，也不采用 Single Channel，粒子特效中较为常见</li>
</ul>
<h3 id="动画">动画</h3>
<p>info : <a href="https://www.techarthub.com/animation-compression-unity/">Animation Compression In Unity</a></p>
<p><strong>Rig 标签：</strong></p>
<p><strong>Animation Type</strong></p>
<ul>
<li>None ：无动画</li>
<li>Legacy ：Unity 3.0 之前的旧版动画，为了向后兼容，该系统仍然可用。使用遗留动画的主要原因是继续处理旧项目，而无需为 <strong>Mecanim</strong> 更新它，但不建议在新项目使用它</li>
<li>Generic ：通用骨骼框架</li>
<li>Humanoid： 人形骨骼框架</li>
</ul>
<p>{% note info %}
Unity 有一个名为 Mecanim 的丰富而复杂的动画系统，它提供：简单的工作流程和人形角色动画设置；动画重新定位并将动画从一个角色模型应用到另一个角色模型的能力。
{%  endnote %}</p>
<p>选择原则</p>
<ul>
<li>无动画选择 None</li>
<li>非人形动画选择 Generic</li>
<li>人形动画
<ul>
<li>人形动画需要 Kinematices 或 Animation Retargeting 功能，或者没有有自定义骨骼对象时选择 Humanoid Rig</li>
<li>其他都选择 Generic Rig，在骨骼数差不多的情况, Genericc Rig 会比 Humanoid Rig 省 30% 甚至更多的 CPU 的时间</li>
</ul>
</li>
</ul>
<p><strong>Skin Weights</strong></p>
<p>默认 4 根骨头，但对于一些不重要的动画对象可以减少到 1 根，节省计算量</p>
<p>在 ProjetSettings 中的 Quality 选项中可对不同平台设备做不同优化</p>
<p><strong>Optimize Bones</strong></p>
<p>建议开启，在导入时自动剔除没有蒙皮顶点的骨骼</p>
<p><strong>Optimize Game Objects</strong></p>
<p>在 Avatar 和 Animatior 组件中删除导入游戏角色对象的变换层级结构，而使用 Unity 动画内部结构骨骼，消减骨骼 transform 带来的性能开销。可以提高角色动画性能, 但有些情况下会造成角色动画错误，这个选项可以尝试开启但要看表现效果而定。注意如果你的角色是可以换装的，在导入时不要开启此选项，但在换装后在运行时在代码中通过调用 <code>AnimatorUtility.OptimizeTransformHierarchy</code> 接口仍然可以达到此选项效果</p>
<p><strong>Animation 标签：</strong></p>
<blockquote>
<p>Back Animation 只在模型是一些 DCC 软件制作导出的才适用</p>
</blockquote>
<p><strong>Resmple Curves</strong></p>
<p>将动画曲线重新采样为四元数数值，并为动画每帧生成一个新的四元数关键帧，仅当导入动画文件包含欧拉曲线时才会显示此选项</p>
<p><strong>Anim.Compression</strong></p>
<ul>
<li>Off： 不压缩, 质量最高，内存消耗最大</li>
<li>Keyframe Reduction ：减少冗余关键帧，减小动画文件大小和内存大小</li>
<li>Keyframe Reduction and Compression： 减小关键帧的同时对关键帧存储数据进行压缩，只影响文件大小</li>
<li>Optimal：仅适用于 Generic 与 Humanoide 动画类型，Unity 决定如何进行压缩</li>
</ul>
<p>{% note primary %}
当选择后三种压缩格式时，都会有 Rotation Error、Position Erro r和 Scale Error，Unity 通过以上三个压缩内容的值来控制删除多少数据（默认是 0.5，表面上从 0 到 100，但可以远远超出这个百分比），这代表了源资产可接受的变化量。允许的变化越大，压缩就越激进，性能提升就越大
{% endnote %}</p>
<p><strong>Animation Custom Properties</strong></p>
<p>导入用户自定义属性，一般对应 DCC 工具中的 extraUserProperties 字段中定义的数据</p>
<p><strong>动画曲线数据信息：</strong></p>
<ul>
<li>Curves Pos: 位置曲线</li>
<li>Quaternion: 四元数曲线 Resample Curves 开启会有</li>
<li>Euler: 欧拉曲线</li>
<li>Scale: 缩放曲线</li>
<li>Muscles: 肌肉曲线，Humanoid 类型下会有</li>
<li>Generic: 一般属性动画曲线，如颜色，材质等</li>
<li>PPtr：精灵动画曲线，一般 2D 系统下会有</li>
<li>Curves Total: 曲线总数</li>
<li>Constant: 优化为常数的曲线</li>
<li>Dense: 使用了密集数据（线性插值后的离散值）存储</li>
<li>Stream: 使用了流式数据（插值的时间和切线数据）存储</li>
</ul>
<p>在动画导入选项尝试一些更改后，可在此选项中查看优化后的信息</p>
<p><strong>动画文件导入设置优化后信息查看原则：</strong></p>
<ol>
<li>一看效果差异（与原始制作动画差异是否明显）</li>
<li>二看曲线数量（总曲线数量与各种曲线数显，常量曲线比重大更好）</li>
<li>三看动画文件大小（以移动平台为例，动画文件在 几百k 或更少为合理，查过 1M 以上的动画文件考虑是否进行了合理优化）</li>
</ol>
<hr>
<p>Chapter 1 End ✅ and keep updated ⚙️</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>NodeCanvas 使用方法指北</title>
      <link>https://brealinhub.com/posts/nodecanvas-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%8C%87%E5%8C%97/</link>
      <pubDate>Sun, 26 Jun 2022 10:31:39 +0000</pubDate>
      
      <guid>https://brealinhub.com/posts/nodecanvas-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%8C%87%E5%8C%97/</guid>
      <description>NodeCanvas 使用方法指北 推荐查看 官方文档 了解全部详情
引用我之前写过的操作文章 bilibili跳转 、csdn跳转</description>
      <content:encoded><![CDATA[<h2 id="nodecanvas-使用方法指北">NodeCanvas 使用方法指北</h2>
<blockquote>
<p>推荐查看 <a href="https://nodecanvas.paradoxnotion.com/"><strong>官方文档</strong></a> 了解全部详情</p>
</blockquote>
<p>引用我之前写过的操作文章 <a href="https://www.bilibili.com/read/cv16199341?spm_id_from=333.999.0.0"><strong>bilibili跳转</strong> </a>、<a href="https://blog.csdn.net/bralin/article/details/124416774?spm=1001.2014.3001.5502"><strong>csdn跳转</strong></a></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
